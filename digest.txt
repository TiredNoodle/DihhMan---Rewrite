Directory structure:
└── DihhMan_Rewrite/
    ├── main.lua
    ├── run_Dihhmann.bat
    ├── lib/
    │   ├── anim8.lua
    │   ├── baton.lua
    │   ├── bitser.lua
    │   ├── middleclass.lua
    │   ├── sock.lua
    │   └── hump/
    │       ├── camera.lua
    │       └── gamestate.lua
    └── src/
        ├── core/
        │   ├── Network.lua
        │   ├── NetworkPlayer.lua
        │   └── World.lua
        ├── entities/
        │   ├── BaseCharacter.lua
        │   ├── Enemy.lua
        │   └── Player.lua
        └── ui/
            ├── BaseMenu.lua
            └── MainMenu.lua

================================================
FILE: main.lua
================================================
-- main.lua - Top-down multiplayer game with corrected networking
-- This is the main entry point for the game that orchestrates all systems
local Network = require "src.core.Network"
local NetworkPlayer = require "src.core.NetworkPlayer"
local World = require "src.core.World"
local BaseCharacter = require "src.entities.BaseCharacter"
local MainMenu = require "src.ui.MainMenu"
local Player = require "src.entities.Player"

-- GAME STATE MANAGEMENT
-- =====================
-- Tracks the current state of the game application
local gameState = "menu"          -- "menu", "connecting", or "playing"
local localPlayer = nil           -- The player controlled by this instance
local remotePlayers = {}          -- Table of other players connected
local myPlayerId = nil            -- Our assigned player ID from server
local enemies = {} 							 	-- Table of active enemies
local mainMenu = nil              -- Main menu UI instance
local debugFont = nil             -- Font for debug information display
local showDebugInfo = true        -- Toggles debug overlay (set to TRUE for debugging)

-- DEBUG: Track frame count for periodic logging
local frameCount = 0
local lastDebugOutput = 0

-- LOVE2D LOAD FUNCTION
-- ====================
-- Initializes game systems and sets up initial state
function love.load()
    love.window.setTitle("Top-Down Network Game")
    love.window.setMode(800, 600)

    -- Initialize subsystems
    debugFont = love.graphics.newFont(12)
    World.init()

    -- Create main menu and link it to the network module
    mainMenu = MainMenu:new()
    mainMenu.network = Network

    -- Configure network event callbacks
    setupNetworkCallbacks()

    -- Start in menu state
    switchGameState("menu")

    print("Game loaded successfully. Press F1 to toggle debug info.")
end

-- NETWORK CALLBACK SETUP
-- ======================
-- Configures how the game responds to various network events
function setupNetworkCallbacks()
    -- Called when connection to server is established
    Network.setConnectCallback(function()
        print("Network: Successfully connected to server!")
        -- CRITICAL FIX: Switch to connecting state when we connect
        if gameState == "menu" then
            switchGameState("connecting")
        end
    end)

    -- Called when server sends initial game state (player positions, IDs, etc.)
    Network.setGameStateCallback(function(data)
        print("Network: Received initial game state from server")
        myPlayerId = data.yourId
        print("My player ID assigned by server:", myPlayerId)

        -- CRITICAL FIX: Always create local player from server data or spawn location
        local spawnX, spawnY
        if data.players and data.players[myPlayerId] then
            -- Use server-provided position
            local playerData = data.players[myPlayerId]
            spawnX = playerData.x
            spawnY = playerData.y
            print(string.format("Creating local player from server data: (%d, %d)", spawnX, spawnY))
        else
            -- Fallback spawn
            spawnX, spawnY = World.findSpawnLocation()
            print(string.format("Creating local player from fallback: (%d, %d)", spawnX, spawnY))
        end

        createLocalPlayer("Player_" .. myPlayerId, spawnX, spawnY)

        -- Create remote players for ALL other players in the game state
        -- This includes the host player if we're a client
        if data.players then
            for id, playerData in pairs(data.players) do
                if id ~= myPlayerId then
                    print("Creating remote player from game state:", id, "at", playerData.x, playerData.y)
                    createRemotePlayer(id, playerData)
                end
            end
        else
            print("WARNING: No players data in game state!")
        end

        -- CRITICAL FIX: Switch to playing state after receiving game state
        switchGameState("playing")
    end)

    -- Called when a new player joins the game (including host when client joins)
    Network.setPlayerJoinedCallback(function(data)
        print("Network: Player joined:", data.id, "at", data.x, data.y)
        -- Only create remote player if it's not our own ID
        if data.id ~= myPlayerId then
            createRemotePlayer(data.id, data)
        else
            print("Ignoring playerJoined for ourselves")
        end
    end)

    -- Called when server sends position updates for other players
    Network.setPlayerUpdatedCallback(function(data)
        if remotePlayers[data.id] then
            remotePlayers[data.id]:applyNetworkUpdate(data)
        else
            print("WARNING: Received update for unknown player:", data.id)
        end
    end)

    -- Called when a player leaves the game
    Network.setPlayerLeftCallback(function(data)
        print("Network: Player left:", data.id)
        if remotePlayers[data.id] then
            remotePlayers[data.id] = nil
            print("Remote player removed:", data.id)
        end
    end)

    -- Called when server corrects our position (collision, cheating prevention)
    Network.setPlayerCorrectedCallback(function(data)
        if localPlayer then
            print("Network: Server corrected our position")
            localPlayer.x = data.x
            localPlayer.y = data.y
        end
    end)

		-- Enemy related stuff
		Network.setEnemySpawnedCallback(function(data)
		    print("Enemy spawned:", data.id, "type:", data.type)
		    createEnemy(data.id, data)
		end)

		Network.setEnemyUpdatedCallback(function(data)
		    if enemies[data.id] then
		        enemies[data.id]:applyNetworkState(data)
		    end
		end)

		Network.setEnemyDiedCallback(function(data)
		    print("Enemy died:", data.id)
		    if enemies[data.id] then
		        enemies[data.id] = nil
		    end
		end)

		-- Called when a player successfully performs an action
		Network.setPlayerActionCallback(function(data)
		    -- Apply action effect to remote player
		    if remotePlayers[data.playerId] then
		        remotePlayers[data.playerId]:applyActionEffect(data)
		    end
		end)

    -- Called when host successfully creates a game
    Network.setHostCreatedCallback(function()
        print("Network: Host game created - creating local player")
        local x, y = World.findSpawnLocation()
        createLocalPlayer("Host", x, y)
        myPlayerId = "host"

        -- IMPORTANT: Update host player data in Network module so clients get it
        if localPlayer then
            Network.setHostPlayerData(localPlayer:getNetworkState())
        end

        switchGameState("playing")
    end)

    -- Called when disconnected from server
    Network.setDisconnectCallback(function(data)
        print("Network: Disconnected from server. Data:", data)
        switchGameState("menu")
    end)
end

-- PLAYER CREATION FUNCTIONS
-- =========================

-- Creates the player controlled by this game instance
-- @param name: Display name for the player
-- @param x: Starting X position (or table with position data)
-- @param y: Starting Y position (if x is not a table)
function createLocalPlayer(name, x, y)
    local spawnX, spawnY

    -- Handle different parameter formats for backward compatibility
    if type(x) == "table" then
        -- Old format: x is a table containing position
        spawnX = x.x or x[1] or 400
        spawnY = x.y or x[2] or 300
    else
        -- New format: separate x and y parameters
        spawnX = x or 400
        spawnY = y or 300
    end

    -- Create player instance and mark as locally controlled
    localPlayer = Player:new(name, spawnX, spawnY)
    localPlayer.isLocalPlayer = true

    print(string.format("Local player '%s' created at (%d, %d)", name, spawnX, spawnY))
end

-- Creates a visual representation of a remote player
-- @param id: Unique network ID of the remote player
-- @param data: Initial state data from server
function createRemotePlayer(id, data)
    -- Check if player already exists
    if remotePlayers[id] then
        print("Remote player already exists:", id)
        return
    end

    local player = NetworkPlayer:new(id, data.x, data.y)
    player.health = data.health or 100
    remotePlayers[id] = player
    print(string.format("Remote player '%s' created at (%d, %d)", id, data.x, data.y))
end

-- Creates a visual representation of a enemy
function createEnemy(enemyId, data)
    local Enemy = require "src.entities.Enemy"
    local enemy = Enemy:new("Enemy_" .. enemyId, data.x, data.y, data.type)
    enemy.health = data.health or 100
    enemy.enemyId = enemyId
    enemies[enemyId] = enemy
    print(string.format("Enemy %s created at (%d, %d)", enemyId, data.x, data.y))
end

-- GAME STATE TRANSITIONS
-- ======================

-- Manages transitions between different game states
-- @param newState: The state to transition to ("menu", "connecting", "playing")
function switchGameState(newState)
    print("Game State Transition:", gameState, "->", newState)
    gameState = newState

    if newState == "menu" then
        cleanupGame()                 -- Clear game objects
        if mainMenu then mainMenu:activate() end
    elseif newState == "connecting" then
        if mainMenu then mainMenu:deactivate() end
    elseif newState == "playing" then
        if mainMenu then mainMenu:deactivate() end
    end
end

-- Cleans up game objects when returning to menu
function cleanupGame()
    localPlayer = nil
    remotePlayers = {}
    myPlayerId = nil
    BaseCharacter.all = {}

    -- Clean up network connections
    if Network.isConnected() then
        -- Network module will handle cleanup through its callbacks
    end
end

-- LOVE2D UPDATE LOOP
-- ==================

-- Main game loop called every frame
-- @param dt: Delta time in seconds since last frame
function love.update(dt)
    Network.update(dt)  -- Process network events

    frameCount = frameCount + 1

    -- DEBUG: Log state every 60 frames (1 second at 60fps)
    if frameCount % 60 == 0 and gameState == "playing" then
        print(string.format("Frame %d: State=%s, LocalPlayer=%s, RemotePlayers=%d",
              frameCount, gameState, tostring(localPlayer ~= nil), tableCount(remotePlayers)))
    end

    if gameState == "menu" then
        if mainMenu then mainMenu:update(dt) end
    elseif gameState == "connecting" then
        -- Waiting for network connection - no updates needed
    elseif gameState == "playing" then
        -- Update local player and send state to server
        if localPlayer then
            localPlayer:update(dt)

            -- Send our current state to the server (if we're a client)
            -- Host doesn't need to send updates to itself
            if Network.isConnected() and localPlayer.isLocalPlayer and not Network.isServer then
                Network.sendPlayerState(localPlayer:getNetworkState())
            elseif Network.isServer then
                -- Host: update our data in the Network module for new clients
								local currentState = localPlayer:getNetworkState()
		            Network.setHostPlayerData(currentState)
            end
        end

        -- Update remote players (interpolation, etc.)
        for id, remotePlayer in pairs(remotePlayers) do
            if remotePlayer then  -- Check if player still exists
                remotePlayer:update(dt)
            end
        end

				-- Update enemies
        for id, enemy in pairs(enemies) do
            if enemy then
                -- Get all players for enemy AI
                local allPlayers = {}
                if localPlayer then table.insert(allPlayers, localPlayer) end
                for _, remotePlayer in pairs(remotePlayers) do
                    if remotePlayer then table.insert(allPlayers, remotePlayer) end
                end

                enemy:update(dt, allPlayers)
            end
        end

        -- Update all base characters (enemies, etc.)
        BaseCharacter.updateAll(dt)
    end
end

-- LOVE2D DRAW LOOP
-- ================

-- Renders the game world and UI
function love.draw()
    -- Draw the static world first
    World.draw()

    -- Draw game elements based on current state
    if gameState == "menu" then
        if mainMenu then mainMenu:draw() end
    elseif gameState == "connecting" then
        -- Draw connecting screen
        love.graphics.setColor(0, 0, 0, 0.8)
        love.graphics.rectangle("fill", 0, 0, 800, 600)
        love.graphics.setColor(1, 1, 1)
        love.graphics.print("Connecting to server...", 350, 300)
    elseif gameState == "playing" then
			-- Draw enemies first (background)
			for id, enemy in pairs(enemies) do
					if enemy then
							enemy:draw()
					end
			end

        -- DEBUG: Draw coordinate grid for troubleshooting
        drawDebugGrid()

        -- DEBUG: Draw a marker at world origin (0,0)
        love.graphics.setColor(1, 0, 0, 0.5)
        love.graphics.circle("fill", 0, 0, 10)
        love.graphics.setColor(1, 1, 1)

        -- Draw remote players
        for id, remotePlayer in pairs(remotePlayers) do
            if remotePlayer then  -- Check if player still exists
                remotePlayer:draw()

                -- DEBUG: Draw position marker for remote player
                love.graphics.setColor(0, 1, 0, 0.5)
                love.graphics.circle("line", remotePlayer.x, remotePlayer.y, 5)
                love.graphics.setColor(1, 1, 1)
            end
        end

        -- Draw local player on top
        if localPlayer then
            localPlayer:draw()
            localPlayer:drawHealthBar()

            -- DEBUG: Draw position marker for local player
            love.graphics.setColor(1, 1, 0, 0.5)
            love.graphics.circle("line", localPlayer.x, localPlayer.y, 8)
            love.graphics.setColor(1, 1, 1)
        else
            print("DEBUG: No local player to draw!")
        end

        -- Draw game UI overlay
        drawGameUI()
    end

    -- Draw debug info overlay if enabled
    if showDebugInfo then
        drawDebugInfo()
    end
end

-- Draws a debug grid to help with coordinate issues
function drawDebugGrid()
    love.graphics.setColor(0.3, 0.3, 0.3, 0.3)
    for x = 0, 800, 50 do
        love.graphics.line(x, 0, x, 600)
        love.graphics.print(tostring(x), x, 10)
    end
    for y = 0, 600, 50 do
        love.graphics.line(0, y, 800, y)
        love.graphics.print(tostring(y), 10, y)
    end
    love.graphics.setColor(1, 1, 1)
end

-- UI RENDERING FUNCTIONS
-- ======================

-- Draws the in-game UI overlay
function drawGameUI()
    love.graphics.setFont(debugFont)

    -- Semi-transparent background for UI
    love.graphics.setColor(0, 0, 0, 0.5)
    love.graphics.rectangle("fill", 5, 5, 250, 120)

    -- UI text
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Game Status", 10, 10)
    love.graphics.print("Mode: " .. (Network.isServer and "HOST" or "CLIENT"), 10, 30)
    love.graphics.print("Connected: " .. (Network.isConnected() and "YES" or "NO"), 10, 50)
    love.graphics.print("My ID: " .. (myPlayerId or "none"), 10, 70)
    love.graphics.print("Remote Players: " .. tableCount(remotePlayers), 10, 90)
    love.graphics.print("Enemies: " .. tableCount(enemies), 10, 350)

    if localPlayer then
        love.graphics.print("Local Pos: " .. math.floor(localPlayer.x) .. "," .. math.floor(localPlayer.y), 10, 110)
    end
end

-- Draws debug information overlay
function drawDebugInfo()
    love.graphics.setFont(debugFont)

    -- Debug panel background
    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", 550, 5, 245, 200)

    -- Debug header
    love.graphics.setColor(0, 1, 0)
    love.graphics.print("DEBUG INFO", 555, 10)

    -- Debug information
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("FPS: " .. love.timer.getFPS(), 555, 30)
    love.graphics.print("State: " .. gameState, 555, 50)
    love.graphics.print("Frame: " .. frameCount, 555, 70)

    -- Player info
    local yPos = 90
    if localPlayer then
        love.graphics.print("Local: " .. localPlayer.name, 555, yPos)
        yPos = yPos + 20
        love.graphics.print("  Pos: " .. math.floor(localPlayer.x) .. "," .. math.floor(localPlayer.y), 555, yPos)
        yPos = yPos + 20
    end

    love.graphics.print("Remote Players: " .. tableCount(remotePlayers), 555, yPos)
    yPos = yPos + 20

    -- Show remote player positions
    for id, player in pairs(remotePlayers) do
        if yPos < 180 then  -- Don't overflow the panel
            love.graphics.print(id .. ": " .. math.floor(player.x) .. "," .. math.floor(player.y), 555, yPos)
            yPos = yPos + 15
        end
    end
end

-- INPUT HANDLING
-- ==============

-- Handles keyboard input events
-- @param key: The key that was pressed
function love.keypressed(key)
    -- Global key bindings (work in any state)
    if key == "escape" then
        if gameState == "playing" then
            switchGameState("menu")
        elseif gameState == "menu" then
            love.event.quit()
        end
    elseif key == "f1" then
        showDebugInfo = not showDebugInfo
    elseif key == "f3" and localPlayer then
        -- Debug: print detailed player state
        print(string.format("Local Player - isLocalPlayer: %s, Position: %d, %d",
              tostring(localPlayer.isLocalPlayer), localPlayer.x, localPlayer.y))
    elseif key == "f5" then
        -- Debug: print network status
        Network.printDebugInfo()
    elseif key == "f6" then
        -- Debug: force create a test remote player
        if gameState == "playing" then
            local testX, testY = World.findSpawnLocation()
            createRemotePlayer("test_debug", {x = testX, y = testY, health = 100})
            print("DEBUG: Created test remote player at", testX, testY)
        end
    end

    -- State-specific key handling
    if gameState == "menu" and mainMenu then
        if key == "up" then
            mainMenu:selectPrevious()
        elseif key == "down" then
            mainMenu:selectNext()
        elseif key == "return" then
            mainMenu:selectCurrent()
        end
    elseif gameState == "playing" then
        if key == "space" and localPlayer then
            print(localPlayer.name .. " performs action!")
        elseif key == "p" then
            -- Debug: print all remote players
            print("=== Remote Players ===")
            for id, player in pairs(remotePlayers) do
                print(string.format("  %s: (%d, %d) Health: %d", id, player.x, player.y, player.health))
            end
        elseif key == "l" then
            -- Debug: print local player info
            if localPlayer then
                print("=== Local Player ===")
                print(string.format("  ID: %s, Position: (%d, %d), Health: %d",
                      myPlayerId, localPlayer.x, localPlayer.y, localPlayer.health))
            end
        elseif key == "r" then
            -- Debug: print render info
            print("=== Render Info ===")
            print("Local player exists:", localPlayer ~= nil)
            print("Remote player count:", tableCount(remotePlayers))
            print("Screen size: 800x600")
            print("Game State:", gameState)
        end
    end
end

-- UTILITY FUNCTIONS
-- =================

-- Counts the number of elements in a table
-- @param t: Table to count
-- @return: Number of key-value pairs
function tableCount(t)
    local count = 0
    for _ in pairs(t) do count = count + 1 end
    return count
end

-- Called when game is closing
function love.quit()
    print("Game closing...")
    return false
end



================================================
FILE: run_Dihhmann.bat
================================================
@echo off
"D:\OSIS\LOVE\love.exe" --console "D:\OSIS\LOVE\LOVE_Projects\DihhMan - Rewrite"


================================================
FILE: lib/anim8.lua
================================================
local anim8 = {
  _VERSION     = 'anim8 v2.3.1',
  _DESCRIPTION = 'An animation library for LÃ–VE',
  _URL         = 'https://github.com/kikito/anim8',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique GarcÃ­a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local Grid = {}

local _frames = {}

local function assertPositiveInteger(value, name)
  if type(value) ~= 'number' then error(("%s should be a number, was %q"):format(name, tostring(value))) end
  if value < 1 then error(("%s should be a positive number, was %d"):format(name, value)) end
  if value ~= math.floor(value) then error(("%s should be an integer, was %f"):format(name, value)) end
end

local function createFrame(self, x, y)
  local fw, fh = self.frameWidth, self.frameHeight
  return love.graphics.newQuad(
    self.left + (x-1) * fw + x * self.border,
    self.top  + (y-1) * fh + y * self.border,
    fw,
    fh,
    self.imageWidth,
    self.imageHeight
  )
end

local function getGridKey(...)
  return table.concat( {...} ,'-' )
end

local function getOrCreateFrame(self, x, y)
  if x < 1 or x > self.width or y < 1 or y > self.height then
    error(("There is no frame for x=%d, y=%d"):format(x, y))
  end
  local key = self._key
  _frames[key]       = _frames[key]       or {}
  _frames[key][x]    = _frames[key][x]    or {}
  _frames[key][x][y] = _frames[key][x][y] or createFrame(self, x, y)
  return _frames[key][x][y]
end

local function parseInterval(str)
  if type(str) == "number" then return str,str,1 end
  str = str:gsub('%s', '') -- remove spaces
  local min, max = str:match("^(%d+)-(%d+)$")
  assert(min and max, ("Could not parse interval from %q"):format(str))
  min, max = tonumber(min), tonumber(max)
  local step = min <= max and 1 or -1
  return min, max, step
end

function Grid:getFrames(...)
  local result, args = {}, {...}
  local minx, maxx, stepx, miny, maxy, stepy

  for i=1, #args, 2 do
    minx, maxx, stepx = parseInterval(args[i])
    miny, maxy, stepy = parseInterval(args[i+1])
    for y = miny, maxy, stepy do
      for x = minx, maxx, stepx do
        result[#result+1] = getOrCreateFrame(self,x,y)
      end
    end
  end

  return result
end

local Gridmt = {
  __index = Grid,
  __call  = Grid.getFrames
}

local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)
  assertPositiveInteger(frameWidth,  "frameWidth")
  assertPositiveInteger(frameHeight, "frameHeight")
  assertPositiveInteger(imageWidth,  "imageWidth")
  assertPositiveInteger(imageHeight, "imageHeight")

  left   = left   or 0
  top    = top    or 0
  border = border or 0

  local key  = getGridKey(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)

  local grid = setmetatable(
    { frameWidth  = frameWidth,
      frameHeight = frameHeight,
      imageWidth  = imageWidth,
      imageHeight = imageHeight,
      left        = left,
      top         = top,
      border      = border,
      width       = math.floor(imageWidth/frameWidth),
      height      = math.floor(imageHeight/frameHeight),
      _key        = key
    },
    Gridmt
  )
  return grid
end

-----------------------------------------------------------

local Animation = {}

local function cloneArray(arr)
  local result = {}
  for i=1,#arr do result[i] = arr[i] end
  return result
end

local function parseDurations(durations, frameCount)
  local result = {}
  if type(durations) == 'number' then
    for i=1,frameCount do result[i] = durations end
  else
    local min, max, step
    for key,duration in pairs(durations) do
      assert(type(duration) == 'number', "The value [" .. tostring(duration) .. "] should be a number")
      min, max, step = parseInterval(key)
      for i = min,max,step do result[i] = duration end
    end
  end

  if #result < frameCount then
    error("The durations table has length of " .. tostring(#result) .. ", but it should be >= " .. tostring(frameCount))
  end

  return result
end

local function parseIntervals(durations)
  local result, time = {0},0
  for i=1,#durations do
    time = time + durations[i]
    result[i+1] = time
  end
  return result, time
end

local Animationmt = { __index = Animation }
local nop = function() end

local function newAnimation(frames, durations, onLoop)
  local td = type(durations);
  if (td ~= 'number' or durations <= 0) and td ~= 'table' then
    error("durations must be a positive number. Was " .. tostring(durations) )
  end
  onLoop = onLoop or nop
  durations = parseDurations(durations, #frames)
  local intervals, totalDuration = parseIntervals(durations)
  return setmetatable({
      frames         = cloneArray(frames),
      durations      = durations,
      intervals      = intervals,
      totalDuration  = totalDuration,
      onLoop         = onLoop,
      timer          = 0,
      position       = 1,
      status         = "playing",
      flippedH       = false,
      flippedV       = false
    },
    Animationmt
  )
end

function Animation:clone()
  local newAnim = newAnimation(self.frames, self.durations, self.onLoop)
  newAnim.flippedH, newAnim.flippedV = self.flippedH, self.flippedV
  return newAnim
end

function Animation:flipH()
  self.flippedH = not self.flippedH
  return self
end

function Animation:flipV()
  self.flippedV = not self.flippedV
  return self
end

local function seekFrameIndex(intervals, timer)
  local high, low, i = #intervals-1, 1, 1

  while(low <= high) do
    i = math.floor((low + high) / 2)
    if     timer >= intervals[i+1] then low  = i + 1
    elseif timer <  intervals[i]   then high = i - 1
    else
      return i
    end
  end

  return i
end

function Animation:update(dt)
  if self.status ~= "playing" then return end

  self.timer = self.timer + dt
  local loops = math.floor(self.timer / self.totalDuration)
  if loops ~= 0 then
    self.timer = self.timer - self.totalDuration * loops
    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]
    f(self, loops)
  end

  self.position = seekFrameIndex(self.intervals, self.timer)
end

function Animation:pause()
  self.status = "paused"
end

function Animation:gotoFrame(position)
  self.position = position
  self.timer = self.intervals[self.position]
end

function Animation:pauseAtEnd()
  self.position = #self.frames
  self.timer = self.totalDuration
  self:pause()
end

function Animation:pauseAtStart()
  self.position = 1
  self.timer = 0
  self:pause()
end

function Animation:resume()
  self.status = "playing"
end

function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)
  love.graphics.draw(image, self:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky))
end

function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)
  local frame = self.frames[self.position]
  if self.flippedH or self.flippedV then
    r,sx,sy,ox,oy,kx,ky = r or 0, sx or 1, sy or 1, ox or 0, oy or 0, kx or 0, ky or 0
    local _,_,w,h = frame:getViewport()

    if self.flippedH then
      sx = sx * -1
      ox = w - ox
      kx = kx * -1
      ky = ky * -1
    end

    if self.flippedV then
      sy = sy * -1
      oy = h - oy
      kx = kx * -1
      ky = ky * -1
    end
  end
  return frame, x, y, r, sx, sy, ox, oy, kx, ky
end

function Animation:getDimensions()
  local _,_,w,h = self.frames[self.position]:getViewport()
  return w,h
end

-----------------------------------------------------------

anim8.newGrid       = newGrid
anim8.newAnimation  = newAnimation

return anim8



================================================
FILE: lib/baton.lua
================================================
local baton = {
	_VERSION = 'Baton v1.0.2',
	_DESCRIPTION = 'Input library for LÃ–VE.',
	_URL = 'https://github.com/tesselode/baton',
	_LICENSE = [[
		MIT License

		Copyright (c) 2020 Andrew Minnich

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
	]]
}

-- string parsing functions --

-- splits a source definition into type and value
-- example: 'button:a' -> 'button', 'a'
local function parseSource(source)
	return source:match '(.+):(.+)'
end

-- splits an axis value into axis and direction
-- example: 'leftx-' -> 'leftx', '-'
local function parseAxis(value)
	return value:match '(.+)([%+%-])'
end

-- splits a joystick hat value into hat number and direction
-- example: '2rd' -> '2', 'rd'
local function parseHat(value)
	return value:match '(%d)(.+)'
end

--[[
	-- source functions --

	each source function checks the state of one type of input
	and returns a value from 0 to 1. for binary controls, such
	as keyboard keys and gamepad buttons, they return 1 if the
	input is held down and 0 if not. for analog controls, such
	as "leftx+" (the left analog stick held to the right), they
	return a number from 0 to 1.

	source functions are split into keyboard/mouse functions
	and joystick/gamepad functions. baton treats these two
	categories slightly differently.
]]

local sourceFunction = {keyboardMouse = {}, joystick = {}}

-- checks whether a keyboard key is down or not
function sourceFunction.keyboardMouse.key(key)
	return love.keyboard.isDown(key) and 1 or 0
end

-- checks whether a keyboard key is down or not,
-- but it takes a scancode as an input
function sourceFunction.keyboardMouse.sc(sc)
	return love.keyboard.isScancodeDown(sc) and 1 or 0
end

-- checks whether a mouse buttons is down or not.
-- note that baton doesn't detect mouse movement, just the buttons
function sourceFunction.keyboardMouse.mouse(button)
	return love.mouse.isDown(tonumber(button)) and 1 or 0
end

-- checks the position of a joystick axis
function sourceFunction.joystick.axis(joystick, value)
	local axis, direction = parseAxis(value)
	-- "a and b or c" is ok here because b will never be boolean
	value = tonumber(axis) and joystick:getAxis(tonumber(axis))
	                        or joystick:getGamepadAxis(axis)
	if direction == '-' then value = -value end
	return value > 0 and value or 0
end

-- checks whether a joystick button is held down or not
-- can take a number or a GamepadButton string
function sourceFunction.joystick.button(joystick, button)
	-- i'm intentionally not using the "a and b or c" idiom here
	-- because joystick.isDown returns a boolean
	if tonumber(button) then
		return joystick:isDown(tonumber(button)) and 1 or 0
	else
		return joystick:isGamepadDown(button) and 1 or 0
	end
end

-- checks the direction of a joystick hat
function sourceFunction.joystick.hat(joystick, value)
	local hat, direction = parseHat(value)
	return joystick:getHat(hat) == direction and 1 or 0
end

--[[
	-- player class --

	the player object takes a configuration table and handles input
	accordingly. it's called a "player" because it makes sense to use
	multiple of these for each player in a multiplayer game, but
	you can use separate player objects to organize inputs
	however you want.
]]

local Player = {}
Player.__index = Player

-- internal functions --

-- sets the player's config to a user-defined config table
-- and sets some defaults if they're not already defined
function Player:_loadConfig(config)
	if not config then
		error('No config table provided', 4)
	end
	if not config.controls then
		error('No controls specified', 4)
	end
	config.pairs = config.pairs or {}
	config.deadzone = config.deadzone or .5
	config.squareDeadzone = config.squareDeadzone or false
	self.config = config
end

-- initializes a control object for each control defined in the config
function Player:_initControls()
	self._controls = {}
	for controlName, sources in pairs(self.config.controls) do
		self._controls[controlName] = {
			sources = sources,
			rawValue = 0,
			value = 0,
			down = false,
			downPrevious = false,
			pressed = false,
			released = false,
		}
	end
end

-- initializes an axis pair object for each axis pair defined in the config
function Player:_initPairs()
	self._pairs = {}
	for pairName, controls in pairs(self.config.pairs) do
		self._pairs[pairName] = {
			controls = controls,
			rawX = 0,
			rawY = 0,
			x = 0,
			y = 0,
			down = false,
			downPrevious = false,
			pressed = false,
			released = false,
		}
	end
end

function Player:_init(config)
	self:_loadConfig(config)
	self:_initControls()
	self:_initPairs()
	self._activeDevice = 'none'
end

--[[
	detects the active device (keyboard/mouse or joystick).
	if the keyboard or mouse is currently being used, joystick
	inputs will be ignored. this is to prevent slight axis movements
	from adding errant inputs when someone's using the keyboard.

	the active device is saved to player._activeDevice, which is then
	used throughout the rest of the update loop to check only
	keyboard or joystick inputs.
]]
function Player:_setActiveDevice()
	-- if the joystick is unset, then we should make sure _activeDevice
	-- isn't "joy" anymore, otherwise there will be an error later
	-- when we try to query a joystick that isn't there
	if self._activeDevice == 'joy' and not self.config.joystick then
		self._activeDevice = 'none'
	end
	for _, control in pairs(self._controls) do
		for _, source in ipairs(control.sources) do
			local type, value = parseSource(source)
			if sourceFunction.keyboardMouse[type] then
				if sourceFunction.keyboardMouse[type](value) > self.config.deadzone then
					self._activeDevice = 'kbm'
					return
				end
			elseif self.config.joystick and sourceFunction.joystick[type] then
				if sourceFunction.joystick[type](self.config.joystick, value) > self.config.deadzone then
					self._activeDevice = 'joy'
				end
			end
		end
	end
end

--[[
	gets the value of a control by running the appropriate source functions
	for all of its sources. does not apply deadzone.
]]
function Player:_getControlRawValue(control)
	local rawValue = 0
	for _, source in ipairs(control.sources) do
		local type, value = parseSource(source)
		if sourceFunction.keyboardMouse[type] and self._activeDevice == 'kbm' then
			if sourceFunction.keyboardMouse[type](value) == 1 then
				return 1
			end
		elseif sourceFunction.joystick[type] and self._activeDevice == 'joy' then
			rawValue = rawValue + sourceFunction.joystick[type](self.config.joystick, value)
			if rawValue >= 1 then
				return 1
			end
		end
	end
	return rawValue
end

--[[
	updates each control in a player. saves the value with and without deadzone
	and the down/pressed/released state.
]]
function Player:_updateControls()
	for _, control in pairs(self._controls) do
		control.rawValue = self:_getControlRawValue(control)
		control.value = control.rawValue >= self.config.deadzone and control.rawValue or 0
		control.downPrevious = control.down
		control.down = control.value > 0
		control.pressed = control.down and not control.downPrevious
		control.released = control.downPrevious and not control.down
	end
end

--[[
	updates each axis pair in a player. saves the value with and without deadzone
	and the down/pressed/released state.
]]
function Player:_updatePairs()
	for _, pair in pairs(self._pairs) do
		-- get raw x and y
		local l = self._controls[pair.controls[1]].rawValue
		local r = self._controls[pair.controls[2]].rawValue
		local u = self._controls[pair.controls[3]].rawValue
		local d = self._controls[pair.controls[4]].rawValue
		pair.rawX, pair.rawY = r - l, d - u

		-- limit to 1
		local len = math.sqrt(pair.rawX^2 + pair.rawY^2)
		if len > 1 then
			pair.rawX, pair.rawY = pair.rawX / len, pair.rawY / len
		end

		-- deadzone
		if self.config.squareDeadzone then
			pair.x = math.abs(pair.rawX) > self.config.deadzone and pair.rawX or 0
			pair.y = math.abs(pair.rawY) > self.config.deadzone and pair.rawY or 0
		else
			pair.x = len > self.config.deadzone and pair.rawX or 0
			pair.y = len > self.config.deadzone and pair.rawY or 0
		end

		-- down/pressed/released
		pair.downPrevious = pair.down
		pair.down = pair.x ~= 0 or pair.y ~= 0
		pair.pressed = pair.down and not pair.downPrevious
		pair.released = pair.downPrevious and not pair.down
	end
end

-- public API --

-- checks for changes in inputs
function Player:update()
	self:_setActiveDevice()
	self:_updateControls()
	self:_updatePairs()
end

-- gets the value of a control or axis pair without deadzone applied
function Player:getRaw(name)
	if self._pairs[name] then
		return self._pairs[name].rawX, self._pairs[name].rawY
	elseif self._controls[name] then
		return self._controls[name].rawValue
	else
		error('No control with name "' .. name .. '" defined', 3)
	end
end

-- gets the value of a control or axis pair with deadzone applied
function Player:get(name)
	if self._pairs[name] then
		return self._pairs[name].x, self._pairs[name].y
	elseif self._controls[name] then
		return self._controls[name].value
	else
		error('No control with name "' .. name .. '" defined', 3)
	end
end

-- gets whether a control or axis pair is "held down"
function Player:down(name)
	if self._pairs[name] then
		return self._pairs[name].down
	elseif self._controls[name] then
		return self._controls[name].down
	else
		error('No control with name "' .. name .. '" defined', 3)
	end
end

-- gets whether a control or axis pair was pressed this frame
function Player:pressed(name)
	if self._pairs[name] then
		return self._pairs[name].pressed
	elseif self._controls[name] then
		return self._controls[name].pressed
	else
		error('No control with name "' .. name .. '" defined', 3)
	end
end

-- gets whether a control or axis pair was released this frame
function Player:released(name)
	if self._pairs[name] then
		return self._pairs[name].released
	elseif self._controls[name] then
		return self._controls[name].released
	else
		error('No control with name "' .. name .. '" defined', 3)
	end
end

--[[
	gets the currently active device (either "kbm", "joy", or "none").
	this is useful for displaying instructional text. you may have
	a menu that says "press ENTER to confirm" or "press A to confirm"
	depending on whether the player is using their keyboard or gamepad.
	this function allows you to detect which they used most recently.
]]
function Player:getActiveDevice()
	return self._activeDevice
end

-- main functions --

-- creates a new player with the user-provided config table
function baton.new(config)
	local player = setmetatable({}, Player)
	player:_init(config)
	return player
end

return baton


================================================
FILE: lib/bitser.lua
================================================
--[[
Copyright (c) 2020-2024, Jasmijn Wellner

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
]]

local VERSION = '1.2'

local floor = math.floor
local pairs = pairs
local type = type
local insert = table.insert
local getmetatable = getmetatable
local setmetatable = setmetatable

local ffi = require("ffi")
local buf_pos = 0
local buf_size = -1
local buf = nil
local buf_is_writable = true
local writable_buf = nil
local writable_buf_size = nil
local includeMetatables = true -- togglable with bitser.includeMetatables(false)
local SEEN_LEN = {}
local NOT_YET_INITIALIZED = {}

local function Buffer_prereserve(min_size)
	if buf_size < min_size then
		buf_size = min_size
		buf = ffi.new("uint8_t[?]", buf_size)
		buf_is_writable = true
	end
end

local function Buffer_clear()
	buf_size = -1
	buf = nil
	buf_is_writable = true
	writable_buf = nil
	writable_buf_size = nil
end

local function Buffer_makeBuffer(size)
	if not buf_is_writable then
		buf = writable_buf
		buf_size = writable_buf_size
		writable_buf = nil
		writable_buf_size = nil
		buf_is_writable = true
	end
	buf_pos = 0
	Buffer_prereserve(size)
end

local function Buffer_newReader(str)
	Buffer_makeBuffer(#str)
	ffi.copy(buf, str, #str)
end

local function Buffer_newDataReader(data, size)
	if buf_is_writable then
		writable_buf = buf
		writable_buf_size = buf_size
	end
	buf_is_writable = false
	buf_pos = 0
	buf_size = size
	buf = ffi.cast("uint8_t*", data)
end

local function Buffer_reserve(additional_size)
	if buf_pos + additional_size > buf_size then
		repeat
			buf_size = buf_size * 2
		until buf_pos + additional_size <= buf_size
		local oldbuf = buf
		buf = ffi.new("uint8_t[?]", buf_size)
		buf_is_writable = true
		ffi.copy(buf, oldbuf, buf_pos)
	end
end

local function Buffer_write_byte(x)
	Buffer_reserve(1)
	buf[buf_pos] = x
	buf_pos = buf_pos + 1
end

local function Buffer_write_raw(data, len)
	Buffer_reserve(len)
	ffi.copy(buf + buf_pos, data, len)
	buf_pos = buf_pos + len
end

local function Buffer_write_string(s)
	Buffer_write_raw(s, #s)
end

local function Buffer_write_data(ct, len, ...)
	Buffer_write_raw(ffi.new(ct, ...), len)
end

local function Buffer_ensure(numbytes)
	if buf_pos + numbytes > buf_size then
		error("malformed serialized data")
	end
end

local function Buffer_read_byte()
	Buffer_ensure(1)
	local x = buf[buf_pos]
	buf_pos = buf_pos + 1
	return x
end

local function Buffer_read_string(len)
	Buffer_ensure(len)
	local x = ffi.string(buf + buf_pos, len)
	buf_pos = buf_pos + len
	return x
end

local function Buffer_read_raw(data, len)
	ffi.copy(data, buf + buf_pos, len)
	buf_pos = buf_pos + len
	return data
end

local function Buffer_read_data(ct, len)
	return Buffer_read_raw(ffi.new(ct), len)
end

local resource_registry = {}
local resource_name_registry = {}
local class_registry = {}
local class_name_registry = {}
local classkey_registry = {}
local class_deserialize_registry = {}
local extension_registry = {}
local extensions_by_type = {}
local EXTENSION_TYPE_KEY = 'bitser-type'
local EXTENSION_MATCH_KEY = 'bitser-match'
local EXTENSION_LOAD_KEY = 'bitser-load'
local EXTENSION_DUMP_KEY = 'bitser-dump'

local serialize_value

local function write_number(value, _)
	if floor(value) == value and value >= -2147483648 and value <= 2147483647 then
		if value >= -27 and value <= 100 then
			--small int
			Buffer_write_byte(value + 27)
		elseif value >= -32768 and value <= 32767 then
			--short int
			Buffer_write_byte(250)
			Buffer_write_data("int16_t[1]", 2, value)
		else
			--long int
			Buffer_write_byte(245)
			Buffer_write_data("int32_t[1]", 4, value)
		end
	else
		--double
		Buffer_write_byte(246)
		Buffer_write_data("double[1]", 8, value)
	end
end

local function write_string(value, _)
	if #value < 32 then
		--short string
		Buffer_write_byte(192 + #value)
	else
		--long string
		Buffer_write_byte(244)
		write_number(#value)
	end
	Buffer_write_string(value)
end

local function write_nil(_, _)
	Buffer_write_byte(247)
end

local function write_boolean(value, _)
	Buffer_write_byte(value and 249 or 248)
end

local function write_table(value, seen)
	local classkey
	local metatable = getmetatable(value)
	local classname = (class_name_registry[value.class] -- MiddleClass
		or class_name_registry[value.__baseclass] -- SECL
		or class_name_registry[metatable] -- hump.class
		or class_name_registry[value.__class__] -- Slither
		or class_name_registry[value.__class]) -- Moonscript class
	if classname then
		classkey = classkey_registry[classname]
		Buffer_write_byte(242)
		serialize_value(classname, seen)
	elseif includeMetatables and metatable then
		Buffer_write_byte(253)
	else
		Buffer_write_byte(240)
	end
	local len = #value
	write_number(len, seen)
	for i = 1, len do
		serialize_value(value[i], seen)
	end
	local klen = 0
	for k in pairs(value) do
		if (type(k) ~= 'number' or floor(k) ~= k or k > len or k < 1) and k ~= classkey then
			klen = klen + 1
		end
	end
	write_number(klen, seen)
	for k, v in pairs(value) do
		if (type(k) ~= 'number' or floor(k) ~= k or k > len or k < 1) and k ~= classkey then
			serialize_value(k, seen)
			serialize_value(v, seen)
		end
	end
	if includeMetatables and metatable and not classname then
		serialize_value(metatable, seen)
	end
end

local types = {number = write_number, string = write_string, table = write_table, boolean = write_boolean, ["nil"] = write_nil}

serialize_value = function(value, seen)
	if seen[value] then
		local ref = seen[value]
		if ref < 64 then
			--small reference
			Buffer_write_byte(128 + ref)
		else
			--long reference
			Buffer_write_byte(243)
			write_number(ref, seen)
		end
		return
	end
	local t = type(value)
	if t ~= 'number' and t ~= 'boolean' and t ~= 'nil' and t ~= 'cdata' then
		seen[value] = seen[SEEN_LEN]
		seen[SEEN_LEN] = seen[SEEN_LEN] + 1
	end
	if resource_name_registry[value] then
		local name = resource_name_registry[value]
		if #name < 16 then
			--small resource
			Buffer_write_byte(224 + #name)
			Buffer_write_string(name)
		else
			--long resource
			Buffer_write_byte(241)
			write_string(name, seen)
		end
		return
	end
	if extensions_by_type[t] then
		for extension_id, extension in pairs(extensions_by_type[t]) do
			if extension[EXTENSION_MATCH_KEY](value) then
				-- extension
				Buffer_write_byte(254)
				serialize_value(extension_id, seen)
				serialize_value(extension[EXTENSION_DUMP_KEY](value), seen)
				return
			end
		end
	end
	(types[t] or
		error("cannot serialize type " .. t)
		)(value, seen)
end

local function serialize(value)
	Buffer_makeBuffer(4096)
	local seen = {[SEEN_LEN] = 0}
	serialize_value(value, seen)
end

local function add_to_seen(value, seen)
	insert(seen, value)
	return value
end

local function reserve_seen(seen)
	insert(seen, NOT_YET_INITIALIZED)
	return #seen
end

local function get_from_seen(seen, idx)
	local value = seen[idx]
	if value == NOT_YET_INITIALIZED then
		error('trying to deserialize a value that has not yet been initialized')
	end
	return value
end

local function deserialize_value(seen)
	local t = Buffer_read_byte()
	if t < 128 then
		--small int
		return t - 27
	elseif t < 192 then
		--small reference
		return get_from_seen(seen, t - 127)
	elseif t < 224 then
		--small string
		return add_to_seen(Buffer_read_string(t - 192), seen)
	elseif t < 240 then
		--small resource
		return add_to_seen(resource_registry[Buffer_read_string(t - 224)], seen)
	elseif t == 240 or t == 253 then
		--table
		local v = add_to_seen({}, seen)
		local len = deserialize_value(seen)
		for i = 1, len do
			v[i] = deserialize_value(seen)
		end
		len = deserialize_value(seen)
		for _ = 1, len do
			local key = deserialize_value(seen)
			v[key] = deserialize_value(seen)
		end
		if t == 253 then
			if includeMetatables then
				setmetatable(v, deserialize_value(seen))
			end
		end
		return v
	elseif t == 241 then
		--long resource
		local idx = reserve_seen(seen)
		local value = resource_registry[deserialize_value(seen)]
		seen[idx] = value
		return value
	elseif t == 242 then
		--instance
		local instance = add_to_seen({}, seen)
		local classname = deserialize_value(seen)
		local class = class_registry[classname]
		local classkey = classkey_registry[classname]
		local deserializer = class_deserialize_registry[classname]
		local len = deserialize_value(seen)
		for i = 1, len do
			instance[i] = deserialize_value(seen)
		end
		len = deserialize_value(seen)
		for _ = 1, len do
			local key = deserialize_value(seen)
			instance[key] = deserialize_value(seen)
		end
		if classkey then
			instance[classkey] = class
		end
		deserializer(instance, class)
		return instance
	elseif t == 243 then
		--reference
		return get_from_seen(seen, deserialize_value(seen) + 1)
	elseif t == 244 then
		--long string
		return add_to_seen(Buffer_read_string(deserialize_value(seen)), seen)
	elseif t == 245 then
		--long int
		return Buffer_read_data("int32_t[1]", 4)[0]
	elseif t == 246 then
		--double
		return Buffer_read_data("double[1]", 8)[0]
	elseif t == 247 then
		--nil
		return nil
	elseif t == 248 then
		--false
		return false
	elseif t == 249 then
		--true
		return true
	elseif t == 250 then
		--short int
		return Buffer_read_data("int16_t[1]", 2)[0]
	elseif t == 254 then
		--extension
		local extension_id = deserialize_value(seen)
		return extension_registry[extension_id][EXTENSION_LOAD_KEY](deserialize_value(seen))
	elseif t == 255 then
		--additional types
		local type_id = deserialize_value(seen)
		error("unsupported serialized type 255+" .. type_id)
	else
		error("unsupported serialized type " .. t)
	end
end

local function deserialize_MiddleClass(instance, class)
	return setmetatable(instance, class.__instanceDict)
end

local function deserialize_SECL(instance, class)
	return setmetatable(instance, getmetatable(class))
end

local deserialize_humpclass = setmetatable

local function deserialize_Slither(instance, class)
	return getmetatable(class).allocate(instance)
end

local function deserialize_Moonscript(instance, class)
	return setmetatable(instance, class.__base)
end

return {dumps = function(value)
	serialize(value)
	return ffi.string(buf, buf_pos)
end, dumpLoveFile = function(fname, value)
	serialize(value)
	assert(love.filesystem.write(fname, ffi.string(buf, buf_pos)))
end, loadLoveFile = function(fname)
	local serializedData, error = love.filesystem.newFileData(fname)
	assert(serializedData, error)
	Buffer_newDataReader(serializedData:getPointer(), serializedData:getSize())
	local value = deserialize_value({})
	-- serializedData needs to not be collected early in a tail-call
	-- so make sure deserialize_value returns before loadLoveFile does
	return value
end, loadData = function(data, size)
	if size == 0 then
		error('cannot load value from empty data')
	end
	Buffer_newDataReader(data, size)
	return deserialize_value({})
end, loads = function(str)
	if #str == 0 then
		error('cannot load value from empty string')
	end
	Buffer_newReader(str)
	return deserialize_value({})
end, includeMetatables = function(bool)
	includeMetatables = not not bool
end, register = function(name, resource)
	assert(not resource_registry[name], name .. " already registered")
	resource_registry[name] = resource
	resource_name_registry[resource] = name
	return resource
end, unregister = function(name)
	resource_name_registry[resource_registry[name]] = nil
	resource_registry[name] = nil
end, registerClass = function(name, class, classkey, deserializer)
	if not class then
		class = name
		name = class.__name__ or class.name or class.__name
	end
	if not classkey then
		if class.__instanceDict then
			-- assume MiddleClass
			classkey = 'class'
		elseif class.__baseclass then
			-- assume SECL
			classkey = '__baseclass'
		end
		-- assume hump.class, Slither, Moonscript class or something else that doesn't store the
		-- class directly on the instance
	end
	if not deserializer then
		if class.__instanceDict then
			-- assume MiddleClass
			deserializer = deserialize_MiddleClass
		elseif class.__baseclass then
			-- assume SECL
			deserializer = deserialize_SECL
		elseif class.__index == class then
			-- assume hump.class
			deserializer = deserialize_humpclass
		elseif class.__name__ then
			-- assume Slither
			deserializer = deserialize_Slither
		elseif class.__base then
			-- assume Moonscript class
			deserializer = deserialize_Moonscript
		else
			error("no deserializer given for unsupported class library")
		end
	end
	class_registry[name] = class
	classkey_registry[name] = classkey
	class_deserialize_registry[name] = deserializer
	class_name_registry[class] = name
	return class
end, unregisterClass = function(name)
	class_name_registry[class_registry[name]] = nil
	classkey_registry[name] = nil
	class_deserialize_registry[name] = nil
	class_registry[name] = nil
end, registerExtension = function(extension_id, extension)
	assert(not extension_registry[extension_id], 'extension with id ' .. extension_id .. ' already registered')
	local ty = extension[EXTENSION_TYPE_KEY]
	assert(type(ty) == 'string' and type(extension[EXTENSION_MATCH_KEY]) == 'function' and type(extension[EXTENSION_LOAD_KEY]) == 'function' and type(extension[EXTENSION_DUMP_KEY]) == 'function', 'not a valid extension')
	extension_registry[extension_id] = extension
	if not extensions_by_type[ty] then
		extensions_by_type[ty] = {}
	end
	extensions_by_type[ty][extension_id] = extension
end, unregisterExtension = function(extension_id)
	extensions_by_type[extension_registry[extension_id][EXTENSION_TYPE_KEY]][extension_id] = nil
	extension_registry[extension_id] = nil
end, reserveBuffer = Buffer_prereserve, clearBuffer = Buffer_clear, version = VERSION}



================================================
FILE: lib/middleclass.lua
================================================
local middleclass = {
  _VERSION     = 'middleclass v4.1.1',
  _DESCRIPTION = 'Object Orientation for Lua',
  _URL         = 'https://github.com/kikito/middleclass',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique GarcÃ­a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local function _createIndexWrapper(aClass, f)
  if f == nil then
    return aClass.__instanceDict
  elseif type(f) == "function" then
    return function(self, name)
      local value = aClass.__instanceDict[name]

      if value ~= nil then
        return value
      else
        return (f(self, name))
      end
    end
  else -- if  type(f) == "table" then
    return function(self, name)
      local value = aClass.__instanceDict[name]

      if value ~= nil then
        return value
      else
        return f[name]
      end
    end
  end
end

local function _propagateInstanceMethod(aClass, name, f)
  f = name == "__index" and _createIndexWrapper(aClass, f) or f
  aClass.__instanceDict[name] = f

  for subclass in pairs(aClass.subclasses) do
    if rawget(subclass.__declaredMethods, name) == nil then
      _propagateInstanceMethod(subclass, name, f)
    end
  end
end

local function _declareInstanceMethod(aClass, name, f)
  aClass.__declaredMethods[name] = f

  if f == nil and aClass.super then
    f = aClass.super.__instanceDict[name]
  end

  _propagateInstanceMethod(aClass, name, f)
end

local function _tostring(self) return "class " .. self.name end
local function _call(self, ...) return self:new(...) end

local function _createClass(name, super)
  local dict = {}
  dict.__index = dict

  local aClass = { name = name, super = super, static = {},
                   __instanceDict = dict, __declaredMethods = {},
                   subclasses = setmetatable({}, {__mode='k'})  }

  if super then
    setmetatable(aClass.static, {
      __index = function(_,k)
        local result = rawget(dict,k)
        if result == nil then
          return super.static[k]
        end
        return result
      end
    })
  else
    setmetatable(aClass.static, { __index = function(_,k) return rawget(dict,k) end })
  end

  setmetatable(aClass, { __index = aClass.static, __tostring = _tostring,
                         __call = _call, __newindex = _declareInstanceMethod })

  return aClass
end

local function _includeMixin(aClass, mixin)
  assert(type(mixin) == 'table', "mixin must be a table")

  for name,method in pairs(mixin) do
    if name ~= "included" and name ~= "static" then aClass[name] = method end
  end

  for name,method in pairs(mixin.static or {}) do
    aClass.static[name] = method
  end

  if type(mixin.included)=="function" then mixin:included(aClass) end
  return aClass
end

local DefaultMixin = {
  __tostring   = function(self) return "instance of " .. tostring(self.class) end,

  initialize   = function(self, ...) end,

  isInstanceOf = function(self, aClass)
    return type(aClass) == 'table'
       and type(self) == 'table'
       and (self.class == aClass
            or type(self.class) == 'table'
            and type(self.class.isSubclassOf) == 'function'
            and self.class:isSubclassOf(aClass))
  end,

  static = {
    allocate = function(self)
      assert(type(self) == 'table', "Make sure that you are using 'Class:allocate' instead of 'Class.allocate'")
      return setmetatable({ class = self }, self.__instanceDict)
    end,

    new = function(self, ...)
      assert(type(self) == 'table', "Make sure that you are using 'Class:new' instead of 'Class.new'")
      local instance = self:allocate()
      instance:initialize(...)
      return instance
    end,

    subclass = function(self, name)
      assert(type(self) == 'table', "Make sure that you are using 'Class:subclass' instead of 'Class.subclass'")
      assert(type(name) == "string", "You must provide a name(string) for your class")

      local subclass = _createClass(name, self)

      for methodName, f in pairs(self.__instanceDict) do
        if not (methodName == "__index" and type(f) == "table") then
          _propagateInstanceMethod(subclass, methodName, f)
        end
      end
      subclass.initialize = function(instance, ...) return self.initialize(instance, ...) end

      self.subclasses[subclass] = true
      self:subclassed(subclass)

      return subclass
    end,

    subclassed = function(self, other) end,

    isSubclassOf = function(self, other)
      return type(other)      == 'table' and
             type(self.super) == 'table' and
             ( self.super == other or self.super:isSubclassOf(other) )
    end,

    include = function(self, ...)
      assert(type(self) == 'table', "Make sure you that you are using 'Class:include' instead of 'Class.include'")
      for _,mixin in ipairs({...}) do _includeMixin(self, mixin) end
      return self
    end
  }
}

function middleclass.class(name, super)
  assert(type(name) == 'string', "A name (string) is needed for the new class")
  return super and super:subclass(name) or _includeMixin(_createClass(name), DefaultMixin)
end

setmetatable(middleclass, { __call = function(_, ...) return middleclass.class(...) end })

return middleclass



================================================
FILE: lib/sock.lua
================================================

--- A Lua networking library for LÃ–VE games.
-- * [Source code](https://github.com/camchenry/sock.lua)
-- * [Examples](https://github.com/camchenry/sock.lua/tree/master/examples)
-- @module sock

local sock = {
    _VERSION     = 'sock.lua v0.3.0',
    _DESCRIPTION = 'A Lua networking library for LÃ–VE games',
    _URL         = 'https://github.com/camchenry/sock.lua',
    _LICENSE     = [[
        MIT License

        Copyright (c) 2016 Cameron McHenry

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in all
        copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
        SOFTWARE.
    ]]
}

local enet = require "enet"

-- Current folder trick
-- http://kiki.to/blog/2014/04/12/rule-5-beware-of-multiple-files/
local currentFolder = (...):gsub('%.[^%.]+$', '')

local bitserLoaded = false

if bitser then
    bitserLoaded = true
end

-- Try to load some common serialization libraries
-- This is for convenience, you may still specify your own serializer
if not bitserLoaded then
    bitserLoaded, bitser = pcall(require, "bitser")
end

-- Try to load relatively
if not bitserLoaded then
    bitserLoaded, bitser = pcall(require, currentFolder .. ".bitser")
end

-- links variables to keys based on their order
-- note that it only works for boolean and number values, not strings
local function zipTable(items, keys, event)
    local data = {}

    -- convert variable at index 1 into the value for the key value at index 1, and so on
    for i, value in ipairs(items) do
        local key = keys[i]

        if not key then
            error("Event '"..event.."' missing data key. Is the schema different between server and client?")
        end

        data[key] = value
    end

    return data
end

--- All of the possible connection statuses for a client connection.
-- @see Client:getState
sock.CONNECTION_STATES = {
    "disconnected",             -- Disconnected from the server.
    "connecting",               -- In the process of connecting to the server.
    "acknowledging_connect",    --
    "connection_pending",       --
    "connection_succeeded",     --
    "connected",                -- Successfully connected to the server.
    "disconnect_later",         -- Disconnecting, but only after sending all queued packets.
    "disconnecting",            -- In the process of disconnecting from the server.
    "acknowledging_disconnect", --
    "zombie",                   --
    "unknown",                  --
}

--- States that represent the client connecting to a server.
sock.CONNECTING_STATES = {
    "connecting",               -- In the process of connecting to the server.
    "acknowledging_connect",    --
    "connection_pending",       --
    "connection_succeeded",     --
}

--- States that represent the client disconnecting from a server.
sock.DISCONNECTING_STATES = {
    "disconnect_later",         -- Disconnecting, but only after sending all queued packets.
    "disconnecting",            -- In the process of disconnecting from the server.
    "acknowledging_disconnect", --
}

--- Valid modes for sending messages.
sock.SEND_MODES = {
    "reliable",     -- Message is guaranteed to arrive, and arrive in the order in which it is sent.
    "unsequenced",  -- Message has no guarantee on the order that it arrives.
    "unreliable",   -- Message is not guaranteed to arrive.
}

local function isValidSendMode(mode)
    for _, validMode in ipairs(sock.SEND_MODES) do
        if mode == validMode then
            return true
        end
    end
    return false
end

local Logger = {}
local Logger_mt = {__index = Logger}

local function newLogger(source)
    local logger = setmetatable({
        source          = source,
        messages        = {},

        -- Makes print info more concise, but should still log the full line
        shortenLines    = true,
        -- Print all incoming event data
        printEventData  = false,
        printErrors     = true,
        printWarnings   = true,
    }, Logger_mt)

    return logger
end

function Logger:log(event, data)
    local time = os.date("%X") -- something like 24:59:59
    local shortLine = ("[%s] %s"):format(event, data)
    local fullLine  = ("[%s][%s][%s] %s"):format(self.source, time, event, data)

    -- The printed message may or may not be the full message
    local line = fullLine
    if self.shortenLines then
        line = shortLine
    end

    if self.printEventData then
        print(line)
    elseif self.printErrors and event == "error" then
        print(line)
    elseif self.printWarnings and event == "warning" then
        print(line)
    end

    -- The logged message is always the full message
    table.insert(self.messages, fullLine)

    -- TODO: Dump to a log file
end

local Listener = {}
local Listener_mt = {__index = Listener}

local function newListener()
    local listener = setmetatable({
        triggers        = {},
        schemas         = {},
    }, Listener_mt)

    return listener
end

-- Adds a callback to a trigger
-- Returns: the callback function
function Listener:addCallback(event, callback)
    if not self.triggers[event] then
        self.triggers[event] = {}
    end

    table.insert(self.triggers[event], callback)

    return callback
end

-- Removes a callback on a given trigger
-- Returns a boolean indicating if the callback was removed
function Listener:removeCallback(callback)
    for _, triggers in pairs(self.triggers) do
        for i, trigger in pairs(triggers) do
            if trigger == callback then
                table.remove(triggers, i)
                return true
            end
        end
    end
    return false
end

-- Accepts: event (string), schema (table)
-- Returns: nothing
function Listener:setSchema(event, schema)
    self.schemas[event] = schema
end

-- Activates all callbacks for a trigger
-- Returns a boolean indicating if any callbacks were triggered
function Listener:trigger(event, data, client)
    if self.triggers[event] then
        for _, trigger in pairs(self.triggers[event]) do
            -- Event has a pre-existing schema defined
            if self.schemas[event] then
                data = zipTable(data, self.schemas[event], event)
            end
            trigger(data, client)
        end
        return true
    else
        return false
    end
end

--- Manages all clients and receives network events.
-- @type Server
local Server = {}
local Server_mt = {__index = Server}

--- Check for network events and handle them.
function Server:update()
    local event = self.host:service(self.messageTimeout)

    while event do
        if event.type == "connect" then
            local eventClient = sock.newClient(event.peer)
            eventClient:setSerialization(self.serialize, self.deserialize)
            table.insert(self.peers, event.peer)
            table.insert(self.clients, eventClient)
            self:_activateTriggers("connect", event.data, eventClient)
            self:log(event.type, tostring(event.peer) .. " connected")

        elseif event.type == "receive" then
            local eventName, data = self:__unpack(event.data)
            local eventClient = self:getClient(event.peer)

            self:_activateTriggers(eventName, data, eventClient)
            self:log(eventName, data)

        elseif event.type == "disconnect" then
            -- remove from the active peer list
            for i, peer in pairs(self.peers) do
                if peer == event.peer then
                    table.remove(self.peers, i)
                end
            end
            local eventClient = self:getClient(event.peer)
            for i, client in pairs(self.clients) do
                if client == eventClient then
                    table.remove(self.clients, i)
                end
            end
            self:_activateTriggers("disconnect", event.data, eventClient)
            self:log(event.type, tostring(event.peer) .. " disconnected")

        end

        event = self.host:service(self.messageTimeout)
    end
end

-- Creates the unserialized message that will be used in callbacks
-- In: serialized message (string)
-- Out: event (string), data (mixed)
function Server:__unpack(data)
    if not self.deserialize then
        self:log("error", "Can't deserialize message: deserialize was not set")
        error("Can't deserialize message: deserialize was not set")
    end

    local message = self.deserialize(data)
    local eventName, data = message[1], message[2]
    return eventName, data
end

-- Creates the serialized message that will be sent over the network
-- In: event (string), data (mixed)
-- Out: serialized message (string)
function Server:__pack(event, data)
    local message = {event, data}
    local serializedMessage

    if not self.serialize then
        self:log("error", "Can't serialize message: serialize was not set")
        error("Can't serialize message: serialize was not set")
    end

    -- 'Data' = binary data class in Love
    if type(data) == "userdata" and data.type and data:typeOf("Data") then
        message[2] = data:getString()
        serializedMessage = self.serialize(message)
    else
        serializedMessage = self.serialize(message)
    end

    return serializedMessage
end

--- Send a message to all clients, except one.
-- Useful for when the client does something locally, but other clients
-- need to be updated at the same time. This way avoids duplicating objects by
-- never sending its own event to itself in the first place.
-- @tparam Client client The client to not receive the message.
-- @tparam string event The event to trigger with this message.
-- @param data The data to send.
function Server:sendToAllBut(client, event, data)
    local serializedMessage = self:__pack(event, data)

    for _, p in pairs(self.peers) do
        if p ~= client.connection then
            self.packetsSent = self.packetsSent + 1
            p:send(serializedMessage, self.sendChannel, self.sendMode)
        end
    end

    self:resetSendSettings()
end

--- Send a message to all clients.
-- @tparam string event The event to trigger with this message.
-- @param data The data to send.
--@usage
--server:sendToAll("gameStarting", true)
function Server:sendToAll(event, data)
    local serializedMessage = self:__pack(event, data)

    self.packetsSent = self.packetsSent + #self.peers

    self.host:broadcast(serializedMessage, self.sendChannel, self.sendMode)

    self:resetSendSettings()
end

--- Send a message to a single peer. Useful to send data to a newly connected player
-- without sending to everyone who already received it.
-- @tparam enet_peer peer The enet peer to receive the message.
-- @tparam string event The event to trigger with this message.
-- @param data data to send to the peer.
--@usage
--server:sendToPeer(peer, "initialGameInfo", {...})
function Server:sendToPeer(peer, event, data)
    local serializedMessage = self:__pack(event, data)

    self.packetsSent = self.packetsSent + 1

    peer:send(serializedMessage, self.sendChannel, self.sendMode)

    self:resetSendSettings()
end

--- Add a callback to an event.
-- @tparam string event The event that will trigger the callback.
-- @tparam function callback The callback to be triggered.
-- @treturn function The callback that was passed in.
--@usage
--server:on("connect", function(data, client)
--    print("Client connected!")
--end)
function Server:on(event, callback)
    return self.listener:addCallback(event, callback)
end

function Server:_activateTriggers(event, data, client)
    local result = self.listener:trigger(event, data, client)

    self.packetsReceived = self.packetsReceived + 1

    if not result then
        self:log("warning", "Tried to activate trigger: '" .. tostring(event) .. "' but it does not exist.")
    end
end

--- Remove a specific callback for an event.
-- @tparam function callback The callback to remove.
-- @treturn boolean Whether or not the callback was removed.
--@usage
--local callback = server:on("chatMessage", function(message)
--    print(message)
--end)
--server:removeCallback(callback)
function Server:removeCallback(callback)
    return self.listener:removeCallback(callback)
end

--- Log an event.
-- Alias for Server.logger:log.
-- @tparam string event The type of event that happened.
-- @tparam string data The message to log.
--@usage
--if somethingBadHappened then
--    server:log("error", "Something bad happened!")
--end
function Server:log(event, data)
    return self.logger:log(event, data)
end

--- Reset all send options to their default values.
function Server:resetSendSettings()
    self.sendMode = self.defaultSendMode
    self.sendChannel = self.defaultSendChannel
end

--- Enables an adaptive order-2 PPM range coder for the transmitted data of all peers. Both the client and server must both either have compression enabled or disabled.
--
-- Note: lua-enet does not currently expose a way to disable the compression after it has been enabled.
function Server:enableCompression()
    return self.host:compress_with_range_coder()
end

--- Destroys the server and frees the port it is bound to.
function Server:destroy()
    self.host:destroy()
end

--- Set the send mode for the next outgoing message.
-- The mode will be reset after the next message is sent. The initial default
-- is "reliable".
-- @tparam string mode A valid send mode.
-- @see SEND_MODES
-- @usage
--server:setSendMode("unreliable")
--server:sendToAll("playerState", {...})
function Server:setSendMode(mode)
    if not isValidSendMode(mode) then
        self:log("warning", "Tried to use invalid send mode: '" .. mode .. "'. Defaulting to reliable.")
        mode = "reliable"
    end

    self.sendMode = mode
end

--- Set the default send mode for all future outgoing messages.
-- The initial default is "reliable".
-- @tparam string mode A valid send mode.
-- @see SEND_MODES
function Server:setDefaultSendMode(mode)
    if not isValidSendMode(mode) then
        self:log("error", "Tried to set default send mode to invalid mode: '" .. mode .. "'")
        error("Tried to set default send mode to invalid mode: '" .. mode .. "'")
    end

    self.defaultSendMode = mode
end

--- Set the send channel for the next outgoing message.
-- The channel will be reset after the next message. Channels are zero-indexed
-- and cannot exceed the maximum number of channels allocated. The initial
-- default is 0.
-- @tparam number channel Channel to send data on.
-- @usage
--server:setSendChannel(2) -- the third channel
--server:sendToAll("importantEvent", "The message")
function Server:setSendChannel(channel)
    if channel > (self.maxChannels - 1) then
        self:log("warning", "Tried to use invalid channel: " .. channel .. " (max is " .. self.maxChannels - 1 .. "). Defaulting to 0.")
        channel = 0
    end

    self.sendChannel = channel
end

--- Set the default send channel for all future outgoing messages.
-- The initial default is 0.
-- @tparam number channel Channel to send data on.
function Server:setDefaultSendChannel(channel)
   self.defaultSendChannel = channel
end

--- Set the data schema for an event.
--
-- Schemas allow you to set a specific format that the data will be sent. If the
-- client and server both know the format ahead of time, then the table keys
-- do not have to be sent across the network, which saves bandwidth.
-- @tparam string event The event to set the data schema for.
-- @tparam {string,...} schema The data schema.
-- @usage
-- server = sock.newServer(...)
-- client = sock.newClient(...)
--
-- -- Without schemas
-- client:send("update", {
--     x = 4,
--     y = 100,
--     vx = -4.5,
--     vy = 23.1,
--     rotation = 1.4365,
-- })
-- server:on("update", function(data, client)
--     -- data = {
--     --    x = 4,
--     --    y = 100,
--     --    vx = -4.5,
--     --    vy = 23.1,
--     --    rotation = 1.4365,
--     -- }
-- end)
--
--
-- -- With schemas
-- server:setSchema("update", {
--     "x",
--     "y",
--     "vx",
--     "vy",
--     "rotation",
-- })
-- -- client no longer has to send the keys, saving bandwidth
-- client:send("update", {
--     4,
--     100,
--     -4.5,
--     23.1,
--     1.4365,
-- })
-- server:on("update", function(data, client)
--     -- data = {
--     --    x = 4,
--     --    y = 100,
--     --    vx = -4.5,
--     --    vy = 23.1,
--     --    rotation = 1.4365,
--     -- }
-- end)
function Server:setSchema(event, schema)
    return self.listener:setSchema(event, schema)
end

--- Set the incoming and outgoing bandwidth limits.
-- @tparam number incoming The maximum incoming bandwidth in bytes.
-- @tparam number outgoing The maximum outgoing bandwidth in bytes.
function Server:setBandwidthLimit(incoming, outgoing)
    return self.host:bandwidth_limit(incoming, outgoing)
end

--- Set the maximum number of channels.
-- @tparam number limit The maximum number of channels allowed. If it is 0,
-- then the maximum number of channels available on the system will be used.
function Server:setMaxChannels(limit)
    self.host:channel_limit(limit)
end

--- Set the timeout to wait for packets.
-- @tparam number timeout Time to wait for incoming packets in milliseconds. The
-- initial default is 0.
function Server:setMessageTimeout(timeout)
    self.messageTimeout = timeout
end

--- Set the serialization functions for sending and receiving data.
-- Both the client and server must share the same serialization method.
-- @tparam function serialize The serialization function to use.
-- @tparam function deserialize The deserialization function to use.
-- @usage
--bitser = require "bitser" -- or any library you like
--server = sock.newServer("localhost", 22122)
--server:setSerialization(bitser.dumps, bitser.loads)
function Server:setSerialization(serialize, deserialize)
    assert(type(serialize) == "function", "Serialize must be a function, got: '"..type(serialize).."'")
    assert(type(deserialize) == "function", "Deserialize must be a function, got: '"..type(deserialize).."'")
    self.serialize = serialize
    self.deserialize = deserialize
end

--- Gets the Client object associated with an enet peer.
-- @tparam peer peer An enet peer.
-- @treturn Client Object associated with the peer.
function Server:getClient(peer)
    for _, client in pairs(self.clients) do
        if peer == client.connection then
            return client
        end
    end
end

--- Gets the Client object that has the given connection id.
-- @tparam number connectId The unique client connection id.
-- @treturn Client
function Server:getClientByConnectId(connectId)
    for _, client in pairs(self.clients) do
        if connectId == client.connectId then
            return client
        end
    end
end

--- Get the Client object that has the given peer index.
-- @treturn Client
function Server:getClientByIndex(index)
    for _, client in pairs(self.clients) do
        if index == client:getIndex() then
            return client
        end
    end
end

--- Get the enet_peer that has the given index.
-- @treturn enet_peer The underlying enet peer object.
function Server:getPeerByIndex(index)
    return self.host:get_peer(index)
end

--- Get the total sent data since the server was created.
-- @treturn number The total sent data in bytes.
function Server:getTotalSentData()
    return self.host:total_sent_data()
end

--- Get the total received data since the server was created.
-- @treturn number The total received data in bytes.
function Server:getTotalReceivedData()
    return self.host:total_received_data()
end
--- Get the total number of packets (messages) sent since the server was created.
-- Everytime a message is sent or received, the corresponding figure is incremented.
-- Therefore, this is not necessarily an accurate indicator of how many packets were actually
-- exchanged over the network.
-- @treturn number The total number of sent packets.
function Server:getTotalSentPackets()
    return self.packetsSent
end

--- Get the total number of packets (messages) received since the server was created.
-- @treturn number The total number of received packets.
-- @see Server:getTotalSentPackets
function Server:getTotalReceivedPackets()
    return self.packetsReceived
end

--- Get the last time when network events were serviced.
-- @treturn number Timestamp of the last time events were serviced.
function Server:getLastServiceTime()
    return self.host:service_time()
end

--- Get the number of allocated slots for peers.
-- @treturn number Number of allocated slots.
function Server:getMaxPeers()
    return self.maxPeers
end

--- Get the number of allocated channels.
-- Channels are zero-indexed, e.g. 16 channels allocated means that the
-- maximum channel that can be used is 15.
-- @treturn number Number of allocated channels.
function Server:getMaxChannels()
    return self.maxChannels
end

--- Get the timeout for packets.
-- @treturn number Time to wait for incoming packets in milliseconds.
-- initial default is 0.
function Server:getMessageTimeout()
    return self.messageTimeout
end

--- Get the socket address of the host.
-- @treturn string A description of the socket address, in the format
-- "A.B.C.D:port" where A.B.C.D is the IP address of the used socket.
function Server:getSocketAddress()
    return self.host:get_socket_address()
end

--- Get the current send mode.
-- @treturn string
-- @see SEND_MODES
function Server:getSendMode()
    return self.sendMode
end

--- Get the default send mode.
-- @treturn string
-- @see SEND_MODES
function Server:getDefaultSendMode()
    return self.defaultSendMode
end

--- Get the IP address or hostname that the server was created with.
-- @treturn string
function Server:getAddress()
    return self.address
end

--- Get the port that the server is hosted on.
-- @treturn number
function Server:getPort()
    return self.port
end

--- Get the table of Clients actively connected to the server.
-- @return {Client,...}
function Server:getClients()
    return self.clients
end

--- Get the number of Clients that are currently connected to the server.
-- @treturn number The number of active clients.
function Server:getClientCount()
    return #self.clients
end


--- Connects to servers.
-- @type Client
local Client = {}
local Client_mt = {__index = Client}

--- Check for network events and handle them.
function Client:update()
    local event = self.host:service(self.messageTimeout)

    while event do
        if event.type == "connect" then
            self:_activateTriggers("connect", event.data)
            self:log(event.type, "Connected to " .. tostring(self.connection))
        elseif event.type == "receive" then
            local eventName, data = self:__unpack(event.data)

            self:_activateTriggers(eventName, data)
            self:log(eventName, data)

        elseif event.type == "disconnect" then
            self:_activateTriggers("disconnect", event.data)
            self:log(event.type, "Disconnected from " .. tostring(self.connection))
        end

        event = self.host:service(self.messageTimeout)
    end
end

--- Connect to the chosen server.
-- Connection will not actually occur until the next time `Client:update` is called.
-- @tparam ?number code A number that can be associated with the connect event.
function Client:connect(code)
    -- number of channels for the client and server must match
    self.connection = self.host:connect(self.address .. ":" .. self.port, self.maxChannels, code)
    self.connectId = self.connection:connect_id()
end

--- Disconnect from the server, if connected. The client will disconnect the
-- next time that network messages are sent.
-- @tparam ?number code A code to associate with this disconnect event.
-- @todo Pass the code into the disconnect callback on the server
function Client:disconnect(code)
    code = code or 0
    self.connection:disconnect(code)
end

--- Disconnect from the server, if connected. The client will disconnect after
-- sending all queued packets.
-- @tparam ?number code A code to associate with this disconnect event.
-- @todo Pass the code into the disconnect callback on the server
function Client:disconnectLater(code)
    code = code or 0
    self.connection:disconnect_later(code)
end

--- Disconnect from the server, if connected. The client will disconnect immediately.
-- @tparam ?number code A code to associate with this disconnect event.
-- @todo Pass the code into the disconnect callback on the server
function Client:disconnectNow(code)
    code = code or 0
    self.connection:disconnect_now(code)
end

--- Forcefully disconnects the client. The server is not notified of the disconnection.
-- @tparam Client client The client to reset.
function Client:reset()
    if self.connection then
        self.connection:reset()
    end
end

-- Creates the unserialized message that will be used in callbacks
-- In: serialized message (string)
-- Out: event (string), data (mixed)
function Client:__unpack(data)
    if not self.deserialize then
        self:log("error", "Can't deserialize message: deserialize was not set")
        error("Can't deserialize message: deserialize was not set")
    end

    local message = self.deserialize(data)
    local eventName, data = message[1], message[2]
    return eventName, data
end

-- Creates the serialized message that will be sent over the network
-- In: event (string), data (mixed)
-- Out: serialized message (string)
function Client:__pack(event, data)
    local message = {event, data}
    local serializedMessage

    if not self.serialize then
        self:log("error", "Can't serialize message: serialize was not set")
        error("Can't serialize message: serialize was not set")
    end

    -- 'Data' = binary data class in Love
    if type(data) == "userdata" and data.type and data:typeOf("Data") then
        message[2] = data:getString()
        serializedMessage = self.serialize(message)
    else
        serializedMessage = self.serialize(message)
    end

    return serializedMessage
end

--- Send a message to the server.
-- @tparam string event The event to trigger with this message.
-- @param data The data to send.
function Client:send(event, data)
    local serializedMessage = self:__pack(event, data)

    self.connection:send(serializedMessage, self.sendChannel, self.sendMode)

    self.packetsSent = self.packetsSent + 1

    self:resetSendSettings()
end

--- Add a callback to an event.
-- @tparam string event The event that will trigger the callback.
-- @tparam function callback The callback to be triggered.
-- @treturn function The callback that was passed in.
--@usage
--client:on("connect", function(data)
--    print("Connected to the server!")
--end)
function Client:on(event, callback)
    return self.listener:addCallback(event, callback)
end

function Client:_activateTriggers(event, data)
    local result = self.listener:trigger(event, data)

    self.packetsReceived = self.packetsReceived + 1

    if not result then
        self:log("warning", "Tried to activate trigger: '" .. tostring(event) .. "' but it does not exist.")
    end
end

--- Remove a specific callback for an event.
-- @tparam function callback The callback to remove.
-- @treturn boolean Whether or not the callback was removed.
--@usage
--local callback = client:on("chatMessage", function(message)
--    print(message)
--end)
--client:removeCallback(callback)
function Client:removeCallback(callback)
    return self.listener:removeCallback(callback)
end

--- Log an event.
-- Alias for Client.logger:log.
-- @tparam string event The type of event that happened.
-- @tparam string data The message to log.
--@usage
--if somethingBadHappened then
--    client:log("error", "Something bad happened!")
--end
function Client:log(event, data)
    return self.logger:log(event, data)
end

--- Reset all send options to their default values.
function Client:resetSendSettings()
    self.sendMode = self.defaultSendMode
    self.sendChannel = self.defaultSendChannel
end

--- Enables an adaptive order-2 PPM range coder for the transmitted data of all peers. Both the client and server must both either have compression enabled or disabled.
--
-- Note: lua-enet does not currently expose a way to disable the compression after it has been enabled.
function Client:enableCompression()
    return self.host:compress_with_range_coder()
end

--- Set the send mode for the next outgoing message.
-- The mode will be reset after the next message is sent. The initial default
-- is "reliable".
-- @tparam string mode A valid send mode.
-- @see SEND_MODES
-- @usage
--client:setSendMode("unreliable")
--client:send("position", {...})
function Client:setSendMode(mode)
    if not isValidSendMode(mode) then
        self:log("warning", "Tried to use invalid send mode: '" .. mode .. "'. Defaulting to reliable.")
        mode = "reliable"
    end

    self.sendMode = mode
end

--- Set the default send mode for all future outgoing messages.
-- The initial default is "reliable".
-- @tparam string mode A valid send mode.
-- @see SEND_MODES
function Client:setDefaultSendMode(mode)
    if not isValidSendMode(mode) then
        self:log("error", "Tried to set default send mode to invalid mode: '" .. mode .. "'")
        error("Tried to set default send mode to invalid mode: '" .. mode .. "'")
    end

    self.defaultSendMode = mode
end

--- Set the send channel for the next outgoing message.
-- The channel will be reset after the next message. Channels are zero-indexed
-- and cannot exceed the maximum number of channels allocated. The initial
-- default is 0.
-- @tparam number channel Channel to send data on.
-- @usage
--client:setSendChannel(2) -- the third channel
--client:send("important", "The message")
function Client:setSendChannel(channel)
    if channel > (self.maxChannels - 1) then
        self:log("warning", "Tried to use invalid channel: " .. channel .. " (max is " .. self.maxChannels - 1 .. "). Defaulting to 0.")
        channel = 0
    end

    self.sendChannel = channel
end

--- Set the default send channel for all future outgoing messages.
-- The initial default is 0.
-- @tparam number channel Channel to send data on.
function Client:setDefaultSendChannel(channel)
    self.defaultSendChannel = channel
end

--- Set the data schema for an event.
--
-- Schemas allow you to set a specific format that the data will be sent. If the
-- client and server both know the format ahead of time, then the table keys
-- do not have to be sent across the network, which saves bandwidth.
-- @tparam string event The event to set the data schema for.
-- @tparam {string,...} schema The data schema.
-- @usage
-- server = sock.newServer(...)
-- client = sock.newClient(...)
--
-- -- Without schemas
-- server:send("update", {
--     x = 4,
--     y = 100,
--     vx = -4.5,
--     vy = 23.1,
--     rotation = 1.4365,
-- })
-- client:on("update", function(data)
--     -- data = {
--     --    x = 4,
--     --    y = 100,
--     --    vx = -4.5,
--     --    vy = 23.1,
--     --    rotation = 1.4365,
--     -- }
-- end)
--
--
-- -- With schemas
-- client:setSchema("update", {
--     "x",
--     "y",
--     "vx",
--     "vy",
--     "rotation",
-- })
-- -- client no longer has to send the keys, saving bandwidth
-- server:send("update", {
--     4,
--     100,
--     -4.5,
--     23.1,
--     1.4365,
-- })
-- client:on("update", function(data)
--     -- data = {
--     --    x = 4,
--     --    y = 100,
--     --    vx = -4.5,
--     --    vy = 23.1,
--     --    rotation = 1.4365,
--     -- }
-- end)
function Client:setSchema(event, schema)
    return self.listener:setSchema(event, schema)
end

--- Set the maximum number of channels.
-- @tparam number limit The maximum number of channels allowed. If it is 0,
-- then the maximum number of channels available on the system will be used.
function Client:setMaxChannels(limit)
    self.host:channel_limit(limit)
end

--- Set the timeout to wait for packets.
-- @tparam number timeout Time to wait for incoming packets in milliseconds. The initial
-- default is 0.
function Client:setMessageTimeout(timeout)
    self.messageTimeout = timeout
end

--- Set the incoming and outgoing bandwidth limits.
-- @tparam number incoming The maximum incoming bandwidth in bytes.
-- @tparam number outgoing The maximum outgoing bandwidth in bytes.
function Client:setBandwidthLimit(incoming, outgoing)
    return self.host:bandwidth_limit(incoming, outgoing)
end

--- Set how frequently to ping the server.
-- The round trip time is updated each time a ping is sent. The initial
-- default is 500ms.
-- @tparam number interval The interval, in milliseconds.
function Client:setPingInterval(interval)
    if self.connection then
        self.connection:ping_interval(interval)
    end
end

--- Change the probability at which unreliable packets should not be dropped.
-- @tparam number interval Interval, in milliseconds, over which to measure lowest mean RTT. (default: 5000ms)
-- @tparam number acceleration Rate at which to increase the throttle probability as mean RTT declines. (default: 2)
-- @tparam number deceleration Rate at which to decrease the throttle probability as mean RTT increases.
function Client:setThrottle(interval, acceleration, deceleration)
    interval = interval or 5000
    acceleration = acceleration or 2
    deceleration = deceleration or 2
    if self.connection then
        self.connection:throttle_configure(interval, acceleration, deceleration)
    end
end

--- Set the parameters for attempting to reconnect if a timeout is detected.
-- @tparam ?number limit A factor that is multiplied with a value that based on the average round trip time to compute the timeout limit. (default: 32)
-- @tparam ?number minimum Timeout value in milliseconds that a reliable packet has to be acknowledged if the variable timeout limit was exceeded. (default: 5000)
-- @tparam ?number maximum Fixed timeout in milliseconds for which any packet has to be acknowledged.
function Client:setTimeout(limit, minimum, maximum)
    limit = limit or 32
    minimum = minimum or 5000
    maximum = maximum or 30000
    if self.connection then
        self.connection:timeout(limit, minimum, maximum)
    end
end

--- Set the serialization functions for sending and receiving data.
-- Both the client and server must share the same serialization method.
-- @tparam function serialize The serialization function to use.
-- @tparam function deserialize The deserialization function to use.
-- @usage
--bitser = require "bitser" -- or any library you like
--client = sock.newClient("localhost", 22122)
--client:setSerialization(bitser.dumps, bitser.loads)
function Client:setSerialization(serialize, deserialize)
    assert(type(serialize) == "function", "Serialize must be a function, got: '"..type(serialize).."'")
    assert(type(deserialize) == "function", "Deserialize must be a function, got: '"..type(deserialize).."'")
    self.serialize = serialize
    self.deserialize = deserialize
end

--- Gets whether the client is connected to the server.
-- @treturn boolean Whether the client is connected to the server.
-- @usage
-- client:connect()
-- client:isConnected() -- false
-- -- After a few client updates
-- client:isConnected() -- true
function Client:isConnected()
    return self.connection ~= nil and self:getState() == "connected"
end

--- Gets whether the client is disconnected from the server.
-- @treturn boolean Whether the client is connected to the server.
-- @usage
-- client:disconnect()
-- client:isDisconnected() -- false
-- -- After a few client updates
-- client:isDisconnected() -- true
function Client:isDisconnected()
    return self.connection ~= nil and self:getState() == "disconnected"
end

--- Gets whether the client is connecting to the server.
-- @treturn boolean Whether the client is connected to the server.
-- @usage
-- client:connect()
-- client:isConnecting() -- true
-- -- After a few client updates
-- client:isConnecting() -- false
-- client:isConnected() -- true
function Client:isConnecting()
    local inConnectingState = false
    for _, state in ipairs(sock.CONNECTING_STATES) do
        if state == self:getState() then
            inConnectingState = true
            break
        end
    end
    return self.connection ~= nil and inConnectingState
end

--- Gets whether the client is disconnecting from the server.
-- @treturn boolean Whether the client is connected to the server.
-- @usage
-- client:disconnect()
-- client:isDisconnecting() -- true
-- -- After a few client updates
-- client:isDisconnecting() -- false
-- client:isDisconnected() -- true
function Client:isDisconnecting()
    local inDisconnectingState = false
    for _, state in ipairs(sock.DISCONNECTING_STATES) do
        if state == self:getState() then
            inDisconnectingState = true
            break
        end
    end
    return self.connection ~= nil and inDisconnectingState
end

--- Get the total sent data since the server was created.
-- @treturn number The total sent data in bytes.
function Client:getTotalSentData()
    return self.host:total_sent_data()
end

--- Get the total received data since the server was created.
-- @treturn number The total received data in bytes.
function Client:getTotalReceivedData()
    return self.host:total_received_data()
end

--- Get the total number of packets (messages) sent since the client was created.
-- Everytime a message is sent or received, the corresponding figure is incremented.
-- Therefore, this is not necessarily an accurate indicator of how many packets were actually
-- exchanged over the network.
-- @treturn number The total number of sent packets.
function Client:getTotalSentPackets()
    return self.packetsSent
end

--- Get the total number of packets (messages) received since the client was created.
-- @treturn number The total number of received packets.
-- @see Client:getTotalSentPackets
function Client:getTotalReceivedPackets()
    return self.packetsReceived
end

--- Get the last time when network events were serviced.
-- @treturn number Timestamp of the last time events were serviced.
function Client:getLastServiceTime()
    return self.host:service_time()
end

--- Get the number of allocated channels.
-- Channels are zero-indexed, e.g. 16 channels allocated means that the
-- maximum channel that can be used is 15.
-- @treturn number Number of allocated channels.
function Client:getMaxChannels()
    return self.maxChannels
end

--- Get the timeout for packets.
-- @treturn number Time to wait for incoming packets in milliseconds.
-- initial default is 0.
function Client:getMessageTimeout()
    return self.messageTimeout
end

--- Return the round trip time (RTT, or ping) to the server, if connected.
-- It can take a few seconds for the time to approach an accurate value.
-- @treturn number The round trip time.
function Client:getRoundTripTime()
    if self.connection then
        return self.connection:round_trip_time()
    end
end

--- Get the unique connection id, if connected.
-- @treturn number The connection id.
function Client:getConnectId()
    if self.connection then
        return self.connection:connect_id()
    end
end

--- Get the current connection state, if connected.
-- @treturn string The connection state.
-- @see CONNECTION_STATES
function Client:getState()
    if self.connection then
        return self.connection:state()
    end
end

--- Get the index of the enet peer. All peers of an ENet host are kept in an array. This function finds and returns the index of the peer of its host structure.
-- @treturn number The index of the peer.
function Client:getIndex()
    if self.connection then
        return self.connection:index()
    end
end

--- Get the socket address of the host.
-- @treturn string A description of the socket address, in the format "A.B.C.D:port" where A.B.C.D is the IP address of the used socket.
function Client:getSocketAddress()
    return self.host:get_socket_address()
end

--- Get the enet_peer that has the given index.
-- @treturn enet_peer The underlying enet peer object.
function Client:getPeerByIndex(index)
    return self.host:get_peer(index)
end

--- Get the current send mode.
-- @treturn string
-- @see SEND_MODES
function Client:getSendMode()
    return self.sendMode
end

--- Get the default send mode.
-- @treturn string
-- @see SEND_MODES
function Client:getDefaultSendMode()
    return self.defaultSendMode
end

--- Get the IP address or hostname that the client was created with.
-- @treturn string
function Client:getAddress()
    return self.address
end

--- Get the port that the client is connecting to.
-- @treturn number
function Client:getPort()
    return self.port
end

--- Creates a new Server object.
-- @tparam ?string address Hostname or IP address to bind to. (default: "localhost")
-- @tparam ?number port Port to listen to for data. (default: 22122)
-- @tparam ?number maxPeers Maximum peers that can connect to the server. (default: 64)
-- @tparam ?number maxChannels Maximum channels available to send and receive data. (default: 1)
-- @tparam ?number inBandwidth Maximum incoming bandwidth (default: 0)
-- @tparam ?number outBandwidth Maximum outgoing bandwidth (default: 0)
-- @return A new Server object.
-- @see Server
-- @within sock
-- @usage
--local sock = require "sock"
--
-- -- Local server hosted on localhost:22122 (by default)
--server = sock.newServer()
--
-- -- Local server only, on port 1234
--server = sock.newServer("localhost", 1234)
--
-- -- Server hosted on static IP 123.45.67.89, on port 22122
--server = sock.newServer("123.45.67.89", 22122)
--
-- -- Server hosted on any IP, on port 22122
--server = sock.newServer("*", 22122)
--
-- -- Limit peers to 10, channels to 2
--server = sock.newServer("*", 22122, 10, 2)
--
-- -- Limit incoming/outgoing bandwidth to 1kB/s (1000 bytes/s)
--server = sock.newServer("*", 22122, 10, 2, 1000, 1000)
sock.newServer = function(address, port, maxPeers, maxChannels, inBandwidth, outBandwidth)
    address         = address or "localhost"
    port            = port or 22122
    maxPeers        = maxPeers or 64
    maxChannels     = maxChannels or 1
    inBandwidth     = inBandwidth or 0
    outBandwidth    = outBandwidth or 0

    local server = setmetatable({
        address         = address,
        port            = port,
        host            = nil,

        messageTimeout  = 0,
        maxChannels     = maxChannels,
        maxPeers        = maxPeers,
        sendMode        = "reliable",
        defaultSendMode = "reliable",
        sendChannel     = 0,
        defaultSendChannel = 0,

        peers           = {},
        clients         = {},

        listener        = newListener(),
        logger          = newLogger("SERVER"),

        serialize       = nil,
        deserialize     = nil,

        packetsSent     = 0,
        packetsReceived = 0,
    }, Server_mt)

    -- ip, max peers, max channels, in bandwidth, out bandwidth
    -- number of channels for the client and server must match
    server.host = enet.host_create(server.address .. ":" .. server.port, server.maxPeers, server.maxChannels)

    if not server.host then
        error("Failed to create the host. Is there another server running on :"..server.port.."?")
    end

    server:setBandwidthLimit(inBandwidth, outBandwidth)

    if bitserLoaded then
        server:setSerialization(bitser.dumps, bitser.loads)
    end

    return server
end

--- Creates a new Client instance.
-- @tparam ?string/peer serverOrAddress Usually the IP address or hostname to connect to. It can also be an enet peer. (default: "localhost")
-- @tparam ?number port Port number of the server to connect to. (default: 22122)
-- @tparam ?number maxChannels Maximum channels available to send and receive data. (default: 1)
-- @return A new Client object.
-- @see Client
-- @within sock
-- @usage
--local sock = require "sock"
--
-- -- Client that will connect to localhost:22122 (by default)
--client = sock.newClient()
--
-- -- Client that will connect to localhost:1234
--client = sock.newClient("localhost", 1234)
--
-- -- Client that will connect to 123.45.67.89:1234, using two channels
-- -- NOTE: Server must also allocate two channels!
--client = sock.newClient("123.45.67.89", 1234, 2)
sock.newClient = function(serverOrAddress, port, maxChannels)
    serverOrAddress = serverOrAddress or "localhost"
    port            = port or 22122
    maxChannels     = maxChannels or 1

    local client = setmetatable({
        address         = nil,
        port            = nil,
        host            = nil,

        connection      = nil,
        connectId       = nil,

        messageTimeout  = 0,
        maxChannels     = maxChannels,
        sendMode        = "reliable",
        defaultSendMode = "reliable",
        sendChannel     = 0,
        defaultSendChannel = 0,

        listener        = newListener(),
        logger          = newLogger("CLIENT"),

        serialize       = nil,
        deserialize     = nil,

        packetsReceived = 0,
        packetsSent     = 0,
    }, Client_mt)

    -- Two different forms for client creation:
    -- 1. Pass in (address, port) and connect to that.
    -- 2. Pass in (enet peer) and set that as the existing connection.
    -- The first would be the common usage for regular client code, while the
    -- latter is mostly used for creating clients in the server-side code.

    -- First form: (address, port)
    if port ~= nil and type(port) == "number" and serverOrAddress ~= nil and type(serverOrAddress) == "string" then
        client.address = serverOrAddress
        client.port = port
        client.host = enet.host_create()

    -- Second form: (enet peer)
    elseif type(serverOrAddress) == "userdata" then
        client.connection = serverOrAddress
        client.connectId = client.connection:connect_id()
    end

    if bitserLoaded then
        client:setSerialization(bitser.dumps, bitser.loads)
    end

    return client
end

return sock



================================================
FILE: lib/hump/camera.lua
================================================
--[[
Copyright (c) 2010-2015 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local _PATH = (...):match('^(.*[%./])[^%.%/]+$') or ''
local cos, sin = math.cos, math.sin

local camera = {}
camera.__index = camera

-- Movement interpolators (for camera locking/windowing)
camera.smooth = {}

function camera.smooth.none()
	return function(dx,dy) return dx,dy end
end

function camera.smooth.linear(speed)
	assert(type(speed) == "number", "Invalid parameter: speed = "..tostring(speed))
	return function(dx,dy, s)
		-- normalize direction
		local d = math.sqrt(dx*dx+dy*dy)
		local dts = math.min((s or speed) * love.timer.getDelta(), d) -- prevent overshooting the goal
		if d > 0 then
			dx,dy = dx/d, dy/d
		end

		return dx*dts, dy*dts
	end
end

function camera.smooth.damped(stiffness)
	assert(type(stiffness) == "number", "Invalid parameter: stiffness = "..tostring(stiffness))
	return function(dx,dy, s)
		local dts = love.timer.getDelta() * (s or stiffness)
		return dx*dts, dy*dts
	end
end


local function new(x,y, zoom, rot, smoother)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	smoother = smoother or camera.smooth.none() -- for locking, see below
	return setmetatable({x = x, y = y, scale = zoom, rot = rot, smoother = smoother}, camera)
end

function camera:lookAt(x,y)
	self.x, self.y = x, y
	return self
end

function camera:move(dx,dy)
	self.x, self.y = self.x + dx, self.y + dy
	return self
end

function camera:position()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach(x,y,w,h, noclip)
	x,y = x or 0, y or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	self._sx,self._sy,self._sw,self._sh = love.graphics.getScissor()
	if not noclip then
		love.graphics.setScissor(x,y,w,h)
	end

	local cx,cy = x+w/2, y+h/2
	love.graphics.push()
	love.graphics.translate(cx, cy)
	love.graphics.scale(self.scale)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
	love.graphics.setScissor(self._sx,self._sy,self._sw,self._sh)
end

function camera:draw(...)
	local x,y,w,h,noclip,func
	local nargs = select("#", ...)
	if nargs == 1 then
		func = ...
	elseif nargs == 5 then
		x,y,w,h,func = ...
	elseif nargs == 6 then
		x,y,w,h,noclip,func = ...
	else
		error("Invalid arguments to camera:draw()")
	end

	self:attach(x,y,w,h,noclip)
	func()
	self:detach()
end

-- world coordinates to camera coordinates
function camera:cameraCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2 + ox, y*self.scale + h/2 + oy
end

-- camera coordinates to world coordinates
function camera:worldCoords(x,y, ox,oy,w,h)
	ox, oy = ox or 0, oy or 0
	w,h = w or love.graphics.getWidth(), h or love.graphics.getHeight()

	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2 - ox) / self.scale, (y - h/2 - oy) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousePosition(ox,oy,w,h)
	local mx,my = love.mouse.getPosition()
	return self:worldCoords(mx,my, ox,oy,w,h)
end

-- camera scrolling utilities
function camera:lockX(x, smoother, ...)
	local dx, dy = (smoother or self.smoother)(x - self.x, self.y, ...)
	self.x = self.x + dx
	return self
end

function camera:lockY(y, smoother, ...)
	local dx, dy = (smoother or self.smoother)(self.x, y - self.y, ...)
	self.y = self.y + dy
	return self
end

function camera:lockPosition(x,y, smoother, ...)
	return self:move((smoother or self.smoother)(x - self.x, y - self.y, ...))
end

function camera:lockWindow(x, y, x_min, x_max, y_min, y_max, smoother, ...)
	-- figure out displacement in camera coordinates
	x,y = self:cameraCoords(x,y)
	local dx, dy = 0,0
	if x < x_min then
		dx = x - x_min
	elseif x > x_max then
		dx = x - x_max
	end
	if y < y_min then
		dy = y - y_min
	elseif y > y_max then
		dy = y - y_max
	end

	-- transform displacement to movement in world coordinates
	local c,s = cos(-self.rot), sin(-self.rot)
	dx,dy = (c*dx - s*dy) / self.scale, (s*dx + c*dy) / self.scale

	-- move
	self:move((smoother or self.smoother)(dx,dy,...))
end

-- the module
return setmetatable({new = new, smooth = camera.smooth},
	{__call = function(_, ...) return new(...) end})



================================================
FILE: lib/hump/gamestate.lua
================================================
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local function __NULL__() end

 -- default gamestate produces error on every callback
local state_init = setmetatable({leave = __NULL__},
		{__index = function() error("Gamestate not initialized. Use Gamestate.switch()") end})
local stack = {state_init}
local initialized_states = setmetatable({}, {__mode = "k"})
local state_is_dirty = true

local GS = {}
function GS.new(t) return t or {} end -- constructor - deprecated!

local function change_state(stack_offset, to, ...)
	local pre = stack[#stack]

	-- initialize only on first call
	;(initialized_states[to] or to.init or __NULL__)(to)
	initialized_states[to] = __NULL__

	stack[#stack+stack_offset] = to
	state_is_dirty = true
	return (to.enter or __NULL__)(to, pre, ...)
end

function GS.switch(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call switch with colon operator")
	;(stack[#stack].leave or __NULL__)(stack[#stack])
	return change_state(0, to, ...)
end

function GS.push(to, ...)
	assert(to, "Missing argument: Gamestate to switch to")
	assert(to ~= GS, "Can't call push with colon operator")
	return change_state(1, to, ...)
end

function GS.pop(...)
	assert(#stack > 1, "No more states to pop!")
	local pre, to = stack[#stack], stack[#stack-1]
	stack[#stack] = nil
	;(pre.leave or __NULL__)(pre)
	state_is_dirty = true
	return (to.resume or __NULL__)(to, pre, ...)
end

function GS.current()
	return stack[#stack]
end

-- XXX: don't overwrite love.errorhandler by default:
--      this callback is different than the other callbacks
--      (see http://love2d.org/wiki/love.errorhandler)
--      overwriting thi callback can result in random crashes (issue #95)
local all_callbacks = { 'draw', 'update' }

-- fetch event callbacks from love.handlers
for k in pairs(love.handlers) do
	all_callbacks[#all_callbacks+1] = k
end

function GS.registerEvents(callbacks)
	local registry = {}
	callbacks = callbacks or all_callbacks
	for _, f in ipairs(callbacks) do
		registry[f] = love[f] or __NULL__
		love[f] = function(...)
			registry[f](...)
			return GS[f](...)
		end
	end
end

-- forward any undefined functions
setmetatable(GS, {__index = function(_, func)
	-- call function only if at least one 'update' was called beforehand
	-- (see issue #46)
	if not state_is_dirty or func == 'update' then
		state_is_dirty = false
		return function(...)
			return (stack[#stack][func] or __NULL__)(stack[#stack], ...)
		end
	end
	return __NULL__
end})

return GS



================================================
FILE: src/core/Network.lua
================================================
-- src/core/Network.lua
-- Main networking module that handles client-server communication
-- Uses sock.lua for underlying network transport and bitser for serialization

local sock = require "lib.sock"
local bitser = require "lib.bitser"
local World = require "src.core.World"

-- NETWORK MODULE DEFINITION
-- =========================
-- Contains all networking logic and state
local Network = {
    isServer = false,           -- True if this instance is hosting
    connectedPlayers = {},      -- Server-only: tracks connected clients
    hostPlayerData = nil,       -- Server-only: host's player data
    lastHostUpdateTime = 0,     -- Server-only: time of last host update broadcast
    hostUpdateInterval = 0.033  -- Server-only: send host updates ~30 times/sec
}

-- Contains Networking for enemies
Network.enemies = {}              -- Server-only: track all enemies
Network.lastEnemySpawnTime = 0    -- Server-only: track enemy spawning
Network.enemySpawnInterval = 5.0  -- Seconds between enemy spawns
Network.maxEnemies = 10           -- Maximum enemies in arena

-- Private variables for network connections
local server, client

-- Helper function to get serializable player data (without client objects)
-- @return: Table containing only serializable player data
local function getSerializablePlayers()
    local playersData = {}

    -- Include host player if exists
    if Network.isServer and Network.hostPlayerData then
        playersData["host"] = {
            id = "host",
            x = Network.hostPlayerData.x,
            y = Network.hostPlayerData.y,
            health = Network.hostPlayerData.health
        }
    end

    -- Include connected clients
    for id, player in pairs(Network.connectedPlayers) do
        playersData[id] = {
            id = player.id,
            x = player.x,
            y = player.y,
            health = player.health
        }
    end
    return playersData
end

-- Broadcast host position updates to all connected clients
local function broadcastHostUpdate()
    if not Network.isServer or not server or not Network.hostPlayerData then
        return
    end

    -- Send host update to all connected clients
    for id, player in pairs(Network.connectedPlayers) do
        player.client:send("playerUpdated", {
            id = "host",
            x = Network.hostPlayerData.x,
            y = Network.hostPlayerData.y,
            health = Network.hostPlayerData.health
        })
    end
end

-- INITIALIZATION
-- ==============
-- Initializes network as either server (host) or client
-- @param host: IP address or hostname to connect to (client) or bind to (server)
-- @param port: Port number for connection
-- @param serverMode: Boolean indicating if this instance should host
function Network.init(host, port, serverMode)
    Network.isServer = serverMode

    if Network.isServer then
        -- SERVER INITIALIZATION
        print(string.format("Initializing server on %s:%d", host, port))
        server = sock.newServer(host, port)
        server:setSerialization(bitser.dumps, bitser.loads)

        -- Server event handlers
        -- sock.lua passes: (data, clientObject) to callbacks
        server:on("connect", function(data, clientObj)
            Network.onClientConnected(clientObj, data)
        end)

        server:on("playerUpdate", function(data, clientObj)
            Network.onPlayerUpdate(data, clientObj)
        end)

        server:on("enemyUpdate", function(data, clientObj)
            Network.onEnemyUpdate(data, clientObj)
        end)

        server:on("playerAction", function(data, clientObj)
            Network.onPlayerAction(data, clientObj)
        end)

        server:on("disconnect", function(data, clientObj)
            Network.onClientDisconnected(clientObj, data)
        end)

        print("Server started successfully. Waiting for connections...")

        -- Notify that host is ready
        if Network.onHostCreatedCallback then
            Network.onHostCreatedCallback()
        end
    else
        -- CLIENT INITIALIZATION
        print(string.format("Initializing client connecting to %s:%d", host, port))
        client = sock.newClient(host, port)
        client:setSerialization(bitser.dumps, bitser.loads)

        -- Client event handlers
        client:on("connect", function(data)
            Network.onConnected(data)
        end)

        client:on("gameState", function(data)
            Network.onGameStateReceived(data)
        end)

        client:on("playerJoined", function(data)
            if Network.onPlayerJoinedCallback then
                Network.onPlayerJoinedCallback(data)
            end
        end)

        client:on("playerUpdated", function(data)
            if Network.onPlayerUpdatedCallback then
                Network.onPlayerUpdatedCallback(data)
            end
        end)

        client:on("playerLeft", function(data)
            if Network.onPlayerLeftCallback then
                Network.onPlayerLeftCallback(data)
            end
        end)

        client:on("playerCorrected", function(data)
            if Network.onPlayerCorrectedCallback then
                Network.onPlayerCorrectedCallback(data)
            end
        end)

        client:on("enemySpawned", function(data)
            if Network.onEnemySpawnedCallback then
                Network.onEnemySpawnedCallback(data)
            end
        end)

        client:on("enemyUpdated", function(data)
            if Network.onEnemyUpdatedCallback then
                Network.onEnemyUpdatedCallback(data)
            end
        end)

        client:on("enemyDied", function(data)
            if Network.onEnemyDiedCallback then
                Network.onEnemyDiedCallback(data)
            end
        end)

        client:on("playerAction", function(data)
            if Network.onPlayerActionCallback then
                Network.onPlayerActionCallback(data)
            end
        end)

        client:on("disconnect", function(data)
            if Network.onDisconnectCallback then
                Network.onDisconnectCallback(data)
            end
        end)

        -- Attempt connection
        client:connect()
        print("Client attempting connection...")
    end
end

-- FRAME UPDATE
-- ============
-- Must be called every frame to process network events
-- @param dt: Delta time (unused by sock but kept for consistency)
function Network.update(dt)
    if Network.isServer and server then
        server:update()
        Network.updateEnemies(dt)  -- Update enemy AI

        -- Periodically broadcast host updates to all clients
        local currentTime = love.timer.getTime()
        if Network.hostPlayerData and currentTime - Network.lastHostUpdateTime > Network.hostUpdateInterval then
            broadcastHostUpdate()
            Network.lastHostUpdateTime = currentTime
        end
    elseif client then
        client:update()
    end
end

-- SERVER EVENT HANDLERS
-- =====================

-- Called when a new client connects to the server
-- @param clientObj: The client object created by sock.lua
-- @param data: Connection data (usually 0)
function Network.onClientConnected(clientObj, data)
    -- Get client ID from the client object
    local clientId = tostring(clientObj:getIndex())
    print("Server: Client connected with ID:", clientId, "Data:", data)

    -- Find a valid spawn location for new player
    local spawnX, spawnY = World.findSpawnLocation()

    -- Store player data (WITHOUT serializing client object in the data we send)
    Network.connectedPlayers[clientId] = {
        client = clientObj,     -- Reference to sock client object (local use only)
        id = clientId,          -- Unique identifier
        x = spawnX,             -- Initial position
        y = spawnY,
        health = 100            -- Initial health
    }

    -- Get serializable player data (without client objects)
    local playersData = getSerializablePlayers()

    -- Send complete game state to the new client (only serializable data!)
    clientObj:send("gameState", {
        players = playersData,
        yourId = clientId
    })

    -- Notify all other clients (including host via callback) about the new player
    -- First, send to other connected clients
    for id, player in pairs(Network.connectedPlayers) do
        if id ~= clientId then
            player.client:send("playerJoined", {
                id = clientId,
                x = spawnX,
                y = spawnY,
                health = 100
            })
        end
    end

    -- IMPORTANT: Also notify the host instance about the new player
    -- The host needs to create a NetworkPlayer for the client
    if Network.onPlayerJoinedCallback then
        Network.onPlayerJoinedCallback({
            id = clientId,
            x = spawnX,
            y = spawnY,
            health = 100
        })
    end
end

-- Called when a client disconnects from server
-- @param clientObj: The client that disconnected
-- @param data: Disconnection data (usually 0)
function Network.onClientDisconnected(clientObj, data)
    local clientId = tostring(clientObj:getIndex())
    print("Server: Client disconnected:", clientId, "Data:", data)

    -- Notify other clients (including host) about the departure
    for id, player in pairs(Network.connectedPlayers) do
        if id ~= clientId then
            player.client:send("playerLeft", {id = clientId})
        end
    end

    -- Also notify host via callback
    if Network.onPlayerLeftCallback then
        Network.onPlayerLeftCallback({id = clientId})
    end

    -- Remove from tracking
    Network.connectedPlayers[clientId] = nil
end

-- Processes position updates from clients
-- @param data: Player state data from client
-- @param clientObj: The client that sent the update
function Network.onPlayerUpdate(data, clientObj)
    if not data or not data.x or not data.y then
        print("Server: Received invalid player update")
        return
    end

    local clientId = tostring(clientObj:getIndex())
    if not Network.connectedPlayers[clientId] then
        print("Server: Received update from unknown client:", clientId)
        return
    end

    local playerData = Network.connectedPlayers[clientId]
    local oldX, oldY = playerData.x, playerData.y

    -- SERVER-SIDE COLLISION VALIDATION
    -- IMPORTANT: Player dimensions must match Player.lua (40x60)

    local PLAYER_WIDTH = 40
    local PLAYER_HEIGHT = 60

    local playerBox = {
        x = data.x - PLAYER_WIDTH/2,    -- Convert center X to top-left X
        y = data.y - PLAYER_HEIGHT/2,   -- Convert center Y to top-left Y
        width = PLAYER_WIDTH,
        height = PLAYER_HEIGHT
    }

    -- Check if new position collides with walls
    local hasCollision = false
    for _, wall in ipairs(World.walls or {}) do
        if playerBox.x < wall.x + wall.width and
           playerBox.x + playerBox.width > wall.x and
           playerBox.y < wall.y + wall.height and
           playerBox.y + playerBox.height > wall.y then
            hasCollision = true
            break
        end
    end

    if not hasCollision then
        -- Accept the update
        playerData.x = data.x
        playerData.y = data.y
        playerData.health = data.health or playerData.health
    else
        -- Reject the update and send correction to client
        clientObj:send("playerCorrected", {x = oldX, y = oldY})
        -- Keep original position
        data.x, data.y = oldX, oldY
        print(string.format("Server: Rejected invalid movement from client %s", clientId))
    end

    -- Broadcast update to all other clients (including host via callback) if position changed
    if oldX ~= data.x or oldY ~= data.y then
        for id, player in pairs(Network.connectedPlayers) do
            if id ~= clientId then
                player.client:send("playerUpdated", {
                    id = clientId,
                    x = data.x,
                    y = data.y,
                    health = playerData.health
                })
            end
        end

        -- Also update host via callback
        if Network.onPlayerUpdatedCallback then
            Network.onPlayerUpdatedCallback({
                id = clientId,
                x = data.x,
                y = data.y,
                health = playerData.health
            })
        end
    end
end

-- PLAYER ACTION HANDLING
-- ======================

function Network.onPlayerAction(data, clientObj)
    if not data or not data.action then return end

    local clientId = tostring(clientObj:getIndex())

    -- Broadcast action to all other clients
    for id, player in pairs(Network.connectedPlayers) do
        if id ~= clientId then
            player.client:send("playerAction", {
                playerId = clientId,
                action = data.action,
                x = data.x,
                y = data.y,
                direction = data.direction,
                targetId = data.targetId,
                targetX = data.targetX,
                targetY = data.targetY
            })
        end
    end

    -- Also notify host
    if Network.onPlayerActionCallback then
        Network.onPlayerActionCallback({
            playerId = clientId,
            action = data.action,
            x = data.x,
            y = data.y,
            direction = data.direction,
            targetId = data.targetId,
            targetX = data.targetX,
            targetY = data.targetY
        })
    end
end

function Network.sendPlayerAction(actionData) -- Client function to send actions
    if client and client:isConnected() then
        client:send("playerAction", actionData)
    end
end

-- ENEMY MANAGEMENT FUNCTIONS
-- ==========================

function Network.spawnEnemy()
    if not Network.isServer or not server then return end

    -- Check if we should spawn more enemies
    if #Network.enemies >= Network.maxEnemies then
        return
    end

    local currentTime = love.timer.getTime()
    if currentTime - Network.lastEnemySpawnTime < Network.enemySpawnInterval then
        return
    end

    -- Spawn enemy at random location
    local spawnX, spawnY = World.findSpawnLocation()
    local enemyTypes = {"melee", "ranged", "boss"}
    local enemyType = enemyTypes[love.math.random(1, #enemyTypes)]

    local enemyId = tostring(love.math.random(10000, 99999))
    local enemyData = {
        id = enemyId,
        x = spawnX,
        y = spawnY,
        type = enemyType,
        health = enemyType == "boss" and 300 or 100
    }

    -- Store enemy
    Network.enemies[enemyId] = enemyData

    -- Broadcast to all clients
    for _, player in pairs(Network.connectedPlayers) do
        player.client:send("enemySpawned", enemyData)
    end

    -- Notify host
    if Network.onEnemySpawnedCallback then
        Network.onEnemySpawnedCallback(enemyData)
    end

    Network.lastEnemySpawnTime = currentTime
    print("Server: Spawned enemy", enemyId, "type:", enemyType)
end

function Network.updateEnemies(dt)
    if not Network.isServer then return end

    -- Spawn enemies periodically
    Network.spawnEnemy()

    -- Update existing enemies (simple AI)
    for enemyId, enemy in pairs(Network.enemies) do
        -- Find nearest player to chase
        local nearestPlayer = nil
        local nearestDistance = math.huge

        -- Check host player
        if Network.hostPlayerData then
            local dx = enemy.x - Network.hostPlayerData.x
            local dy = enemy.y - Network.hostPlayerData.y
            local distance = math.sqrt(dx*dx + dy*dy)
            if distance < nearestDistance then
                nearestDistance = distance
                nearestPlayer = Network.hostPlayerData
            end
        end

        -- Check connected clients
        for _, player in pairs(Network.connectedPlayers) do
            local dx = enemy.x - player.x
            local dy = enemy.y - player.y
            local distance = math.sqrt(dx*dx + dy*dy)
            if distance < nearestDistance then
                nearestDistance = distance
                nearestPlayer = player
            end
        end

        -- Move enemy toward nearest player
        if nearestPlayer and nearestDistance > 50 then
            local dx = nearestPlayer.x - enemy.x
            local dy = nearestPlayer.y - enemy.y
            local dist = math.sqrt(dx*dx + dy*dy)

            if dist > 0 then
                local speed = enemy.type == "boss" and 80 or
                             enemy.type == "ranged" and 100 or 120
                enemy.x = enemy.x + (dx/dist) * speed * dt
                enemy.y = enemy.y + (dy/dist) * speed * dt

                -- Broadcast update to all clients
                for _, player in pairs(Network.connectedPlayers) do
                    player.client:send("enemyUpdated", {
                        id = enemyId,
                        x = math.floor(enemy.x),
                        y = math.floor(enemy.y),
                        health = enemy.health
                    })
                end

                -- Notify host
                if Network.onEnemyUpdatedCallback then
                    Network.onEnemyUpdatedCallback({
                        id = enemyId,
                        x = math.floor(enemy.x),
                        y = math.floor(enemy.y),
                        health = enemy.health
                    })
                end
            end
        end
    end
end



-- CLIENT EVENT HANDLERS
-- =====================

-- Called when client successfully connects to server
-- @param data: Connection data (usually 0)
function Network.onConnected(data)
    print("Client: Successfully connected to server! Data:", data)
    if Network.onConnectCallback then
        Network.onConnectCallback()
    end
end

-- Called when client receives initial game state from server
-- @param data: Complete game state including all player positions
function Network.onGameStateReceived(data)
    print("Client: Received initial game state from server")
    if Network.onGameStateCallback then
        Network.onGameStateCallback(data)
    end
end

-- HOST PLAYER MANAGEMENT
-- ======================

-- Sets the host's player data for inclusion in game state
-- @param playerData: Host player's state data
function Network.setHostPlayerData(playerData)
    Network.hostPlayerData = playerData
end

-- CALLBACK REGISTRATION FUNCTIONS
-- ===============================
-- These allow main.lua to specify how to handle network events

function Network.setConnectCallback(callback)
    Network.onConnectCallback = callback
end

function Network.setGameStateCallback(callback)
    Network.onGameStateCallback = callback
end

function Network.setPlayerJoinedCallback(callback)
    Network.onPlayerJoinedCallback = callback
end

function Network.setPlayerUpdatedCallback(callback)
    Network.onPlayerUpdatedCallback = callback
end

function Network.setPlayerLeftCallback(callback)
    Network.onPlayerLeftCallback = callback
end

function Network.setPlayerCorrectedCallback(callback)
    Network.onPlayerCorrectedCallback = callback
end

function Network.setEnemySpawnedCallback(callback)
    Network.onEnemySpawnedCallback = callback
end

function Network.setEnemyUpdatedCallback(callback)
    Network.onEnemyUpdatedCallback = callback
end

function Network.setEnemyDiedCallback(callback)
    Network.onEnemyDiedCallback = callback
end

function Network.setPlayerActionCallback(callback)
    Network.onPlayerActionCallback = callback
end

function Network.setHostCreatedCallback(callback)
    Network.onHostCreatedCallback = callback
end

function Network.setDisconnectCallback(callback)
    Network.onDisconnectCallback = callback
end

-- CLIENT NETWORKING FUNCTIONS
-- ===========================

-- Sends current player state to server
-- @param stateData: Player position and state to send
function Network.sendPlayerState(stateData)
    if client and client:isConnected() then
        client:send("playerUpdate", stateData)
    end
end

-- UTILITY FUNCTIONS
-- =================

-- Checks if network connection is active
-- @return: Boolean indicating connection status
function Network.isConnected()
    if Network.isServer then
        return server ~= nil
    else
        return client and client:isConnected()
    end
end

-- Prints debug information about network status
function Network.printDebugInfo()
    print("=== Network Debug Information ===")
    print("Mode:", Network.isServer and "SERVER" or "CLIENT")
    print("Connected:", Network.isConnected())

    if Network.isServer then
        print("Connected clients:", #server:getClients())
        for id, player in pairs(Network.connectedPlayers) do
            print(string.format("  Client %s at (%d, %d)", id, player.x, player.y))
        end
        if Network.hostPlayerData then
            print(string.format("  Host at (%d, %d)",
                  Network.hostPlayerData.x, Network.hostPlayerData.y))
        end
    end
end

return Network



================================================
FILE: src/core/NetworkPlayer.lua
================================================
-- src/core/NetworkPlayer.lua
-- Represents a remote player in the game world
-- Handles interpolation and display of other players' characters

local class = require "lib.middleclass"

local NetworkPlayer = class('NetworkPlayer')

-- Constructor: Creates a new remote player representation
-- @param playerId: Unique network ID of the player
-- @param x: Initial X position (CENTER position from network)
-- @param y: Initial Y position (CENTER position from network)
function NetworkPlayer:initialize(playerId, x, y)
    self.id = playerId            -- Network identifier
    self.width = 40               -- Display dimensions (match Player.lua)
    self.height = 60              -- Display dimensions (match Player.lua)

    -- Store CENTER position for interpolation (what we receive from network)
    self.centerX = x              -- Center X position
    self.centerY = y              -- Center Y position
    self.targetCenterX = x        -- Target center position for interpolation
    self.targetCenterY = y

    -- Calculate top-left corner for drawing
    self.x = x - self.width/2     -- Top-left X for drawing
    self.y = y - self.height/2    -- Top-left Y for drawing

    self.health = 100             -- Current health
    self.maxHealth = 100          -- Maximum health
    self.isLocal = false          -- Always false for NetworkPlayer
    self.isAlive = true           -- Player state
    self.lastUpdateTime = 0       -- Timestamp of last update
    self.name = "Player_" .. playerId  -- Display name

    print(string.format("NetworkPlayer created: ID=%s at center (%d, %d)", playerId, x, y))
end

-- Update loop: Smoothly interpolates position toward target
-- @param dt: Delta time in seconds
function NetworkPlayer:update(dt)
    -- Only interpolate if we have a target different from current position
    if self.targetCenterX ~= self.centerX or self.targetCenterY ~= self.centerY then
        -- Linear interpolation for smooth movement
        -- Higher speed = faster interpolation, lower = smoother
        local interpolationSpeed = 8

        -- Calculate distance to target
        local dx = self.targetCenterX - self.centerX
        local dy = self.targetCenterY - self.centerY
        local distance = math.sqrt(dx * dx + dy * dy)

        -- If we're very close, snap to target
        if distance < 1 then
            self.centerX = self.targetCenterX
            self.centerY = self.targetCenterY
        else
            -- Interpolate with speed proportional to distance
            self.centerX = self.centerX + dx * interpolationSpeed * dt
            self.centerY = self.centerY + dy * interpolationSpeed * dt
        end

        -- Update top-left corner for drawing
        self.x = self.centerX - self.width/2
        self.y = self.centerY - self.height/2
    end
end

-- Draws the remote player character
function NetworkPlayer:draw()
    if not self.isAlive then return end  -- Don't draw dead players

    -- Draw shadow for depth
    love.graphics.setColor(0, 0, 0, 0.3)
    love.graphics.rectangle('fill', self.x + 3, self.y + 5, self.width, self.height)

    -- Remote players are drawn in red to distinguish from local player
    love.graphics.setColor(0.8, 0.2, 0.2)  -- Red

    -- Draw player body (top-left corner)
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)

    -- Draw simple face/eyes (distinguish from local player)
    love.graphics.setColor(1, 1, 1)  -- White eyes for remote players
    local eyeSize = 6
    local eyeOffsetX = 10
    local eyeOffsetY = 15

    -- Left eye
    love.graphics.rectangle("fill",
        self.x + eyeOffsetX,
        self.y + eyeOffsetY,
        eyeSize,
        eyeSize
    )

    -- Right eye
    love.graphics.rectangle("fill",
        self.x + self.width - eyeOffsetX - eyeSize,
        self.y + eyeOffsetY,
        eyeSize,
        eyeSize
    )

    -- Draw name tag above player
    love.graphics.setColor(1, 1, 1)
    local font = love.graphics.newFont(10)
    love.graphics.setFont(font)
    local nameWidth = font:getWidth(self.name)
    love.graphics.print(self.name,
        self.x + self.width/2 - nameWidth/2,
        self.y - 15
    )

    -- Health bar (only shown if damaged)
    self:drawHealthBar()

    love.graphics.setColor(1, 1, 1)  -- Reset to white
end

-- Draws health bar above the player
function NetworkPlayer:drawHealthBar()
    if self.health < self.maxHealth then
        local barWidth = 50
        local barHeight = 6
        local healthPercent = self.health / self.maxHealth

        -- Position above player (centered)
        local barX = self.x + self.width/2 - barWidth/2
        local barY = self.y - 10

        -- Background
        love.graphics.setColor(0.2, 0.2, 0.2)
        love.graphics.rectangle("fill", barX, barY, barWidth, barHeight)

        -- Health fill (green to red based on health)
        local r = 1 - healthPercent  -- Red increases as health decreases
        local g = healthPercent      -- Green decreases as health decreases
        love.graphics.setColor(r, g, 0)
        love.graphics.rectangle("fill", barX, barY, barWidth * healthPercent, barHeight)

        -- Border
        love.graphics.setColor(0, 0, 0)
        love.graphics.rectangle("line", barX, barY, barWidth, barHeight)
    end
end

-- Applies network update to this player
-- @param data: Network data containing new CENTER position and state
function NetworkPlayer:applyNetworkUpdate(data)
    if not data then return end

    -- Store new target CENTER position for interpolation
    self.targetCenterX = data.x or self.targetCenterX
    self.targetCenterY = data.y or self.targetCenterY

    -- Update health
    if data.health then
        self.health = data.health
    end

    -- Update alive status
    if data.alive ~= nil then
        self.isAlive = (data.alive == 1) or data.alive == true
    end

    self.lastUpdateTime = love.timer.getTime()

    -- Debug output for significant position changes
    local dx = math.abs(self.targetCenterX - self.centerX)
    local dy = math.abs(self.targetCenterY - self.centerY)
    if dx > 10 or dy > 10 then
        print(string.format("NetworkPlayer %s: Moving to center (%d, %d)",
              self.id, self.targetCenterX, self.targetCenterY))
    end
end

-- Returns bounding box for collision detection (top-left corner)
-- @return: Table with x, y, width, height
function NetworkPlayer:getBoundingBox()
    return {
        x = self.x,        -- Top-left X
        y = self.y,        -- Top-left Y
        width = self.width,
        height = self.height
    }
end

-- Returns the center position of the player
-- @return: centerX, centerY
function NetworkPlayer:getCenter()
    return self.centerX, self.centerY
end

-- Checks collision with another object
-- @param other: Object with getBoundingBox method or bounding box table
-- @return: Boolean indicating collision
function NetworkPlayer:collidesWith(other)
    local box1 = self:getBoundingBox()
    local box2 = other.getBoundingBox and other:getBoundingBox() or other

    -- Axis-Aligned Bounding Box (AABB) collision detection
    return box1.x < box2.x + box2.width and
           box1.x + box1.width > box2.x and
           box1.y < box2.y + box2.height and
           box1.y + box1.height > box2.y
end

-- Applies damage to the remote player
-- @param amount: Damage amount to subtract from health
function NetworkPlayer:takeDamage(amount)
    self.health = math.max(0, self.health - amount)
    print(string.format("NetworkPlayer %s took %d damage (Health: %d)",
          self.id, amount, self.health))

    if self.health <= 0 then
        self.isAlive = false
        print(string.format("NetworkPlayer %s has died!", self.id))
    end
end

-- Calculates distance to another object (center to center)
-- @param other: Object with getCenter method or x,y properties
-- @return: Euclidean distance between centers
function NetworkPlayer:distanceTo(other)
    local otherCenterX, otherCenterY
    if other.getCenter then
        otherCenterX, otherCenterY = other:getCenter()
    else
        otherCenterX, otherCenterY = other.x, other.y
    end

    local dx = otherCenterX - self.centerX
    local dy = otherCenterY - self.centerY
    return math.sqrt(dx * dx + dy * dy)
end

-- Returns network state for this player (for debugging)
-- @return: Table with current player state (center position)
function NetworkPlayer:getState()
    return {
        id = self.id,
        x = math.floor(self.centerX),
        y = math.floor(self.centerY),
        health = self.health,
        alive = self.isAlive
    }
end

-- String representation for debugging
-- @return: Formatted string describing the player
function NetworkPlayer:__tostring()
    return string.format("NetworkPlayer[%s] at center (%.1f, %.1f) Health: %d/%d Alive: %s",
        self.id, self.centerX, self.centerY, self.health, self.maxHealth, tostring(self.isAlive))
end

return NetworkPlayer



================================================
FILE: src/core/World.lua
================================================
-- World.lua - Empty arena for multiplayer combat
local World = {}
World.walls = {}
World.groundTiles = {}
World.gridSize = 32  -- Size of each tile in pixels
World.width = 800    -- Screen width
World.height = 600   -- Screen height
World.spawnPoints = {} -- Designated spawn points for players

-- Initialize the world as an empty arena
function World.init()
    -- Clear existing walls
    World.walls = {}

    -- Define arena boundary (optional - you can remove for completely open)
    local wallTypes = {
        boundary = {color = {0.2, 0.2, 0.4}, thickness = 1.0}  -- Dark blue
    }

    -- Optional: Create boundary walls (screen edges) - COMMENT OUT FOR OPEN ARENA
    --[[
    table.insert(World.walls, {
        x = 0, y = 0, width = World.width, height = 10,
        type = "boundary", properties = wallTypes.boundary
    })
    table.insert(World.walls, {
        x = 0, y = World.height - 10, width = World.width, height = 10,
        type = "boundary", properties = wallTypes.boundary
    })
    table.insert(World.walls, {
        x = 0, y = 0, width = 10, height = World.height,
        type = "boundary", properties = wallTypes.boundary
    })
    table.insert(World.walls, {
        x = World.width - 10, y = 0, width = 10, height = World.height,
        type = "boundary", properties = wallTypes.boundary
    })
    --]]

    -- Create designated spawn points around the arena
    World.spawnPoints = {
        {x = 100, y = 100},        -- Top-left
        {x = World.width - 100, y = 100},  -- Top-right
        {x = 100, y = World.height - 100}, -- Bottom-left
        {x = World.width - 100, y = World.height - 100}, -- Bottom-right
        {x = World.width / 2, y = 100},    -- Top-center
        {x = World.width / 2, y = World.height - 100}, -- Bottom-center
        {x = 100, y = World.height / 2},   -- Middle-left
        {x = World.width - 100, y = World.height / 2}  -- Middle-right
    }

    -- Generate ground tiles (visual only)
    World.generateGroundTiles()

    print("Empty arena initialized with " .. #World.walls .. " walls")
end

-- Generate a checkerboard ground pattern
function World.generateGroundTiles()
    World.groundTiles = {}
    local tileSize = World.gridSize

    for x = 0, World.width, tileSize do
        for y = 0, World.height, tileSize do
            local isDark = ((math.floor(x / tileSize) + math.floor(y / tileSize)) % 2) == 0
            table.insert(World.groundTiles, {
                x = x, y = y,
                color = isDark and {0.2, 0.2, 0.2} or {0.25, 0.25, 0.25} -- Darker for arena
            })
        end
    end
end

-- Draw the world (call this in love.draw, before drawing entities)
function World.draw()
    -- Draw ground tiles first
    for _, tile in ipairs(World.groundTiles) do
        love.graphics.setColor(tile.color)
        love.graphics.rectangle("fill", tile.x, tile.y, World.gridSize, World.gridSize)
    end

    -- Draw grid lines (optional, for debugging)
    love.graphics.setColor(0.1, 0.1, 0.1, 0.3)
    for x = 0, World.width, World.gridSize do
        love.graphics.line(x, 0, x, World.height)
    end
    for y = 0, World.height, World.gridSize do
        love.graphics.line(0, y, World.width, y)
    end

    -- Draw walls (if any)
    for _, wall in ipairs(World.walls) do
        if wall.properties and wall.properties.color then
            love.graphics.setColor(wall.properties.color)
        else
            love.graphics.setColor(0.5, 0.3, 0.1) -- Default wall color
        end

        love.graphics.rectangle("fill", wall.x, wall.y, wall.width, wall.height)

        -- Draw wall outline
        love.graphics.setColor(0.2, 0.2, 0.2)
        love.graphics.rectangle("line", wall.x, wall.y, wall.width, wall.height)
    end

    love.graphics.setColor(1, 1, 1)
end

-- Get a random spawn point
function World.getRandomSpawnPoint()
    if #World.spawnPoints > 0 then
        local spawn = World.spawnPoints[love.math.random(1, #World.spawnPoints)]
        return spawn.x, spawn.y
    end
    return World.width / 2, World.height / 2
end

-- Check collision between two rectangles (AABB collision)
function World.checkCollision(rect1, rect2)
    return rect1.x < rect2.x + rect2.width and
           rect1.x + rect1.width > rect2.x and
           rect1.y < rect2.y + rect2.height and
           rect1.y + rect1.height > rect2.y
end

-- Check if a rectangle collides with any wall
function World.checkWallCollision(rect)
    for _, wall in ipairs(World.walls) do
        if World.checkCollision(rect, wall) then
            return true, wall
        end
    end
    return false, nil
end

-- Check if point is inside any wall (for spawn point validation)
function World.isPointInWall(x, y)
    for _, wall in ipairs(World.walls) do
        if x >= wall.x and x <= wall.x + wall.width and
           y >= wall.y and y <= wall.y + wall.height then
            return true
        end
    end
    return false
end

-- Find a valid spawn location (not in walls)
function World.findSpawnLocation()
    -- Use designated spawn points
    return World.getRandomSpawnPoint()
end

return World



================================================
FILE: src/entities/BaseCharacter.lua
================================================
-- src/entities/BaseCharacter.lua
-- Base class for all characters in the game.
local class = require "lib.middleclass"
local World = require "src.core.World" -- Required for world interaction

local BaseCharacter = class('BaseCharacter')

-- Constructor: called when creating a new instance (e.g., BaseCharacter:new())
function BaseCharacter:initialize(name, x, y)
    self.name = name or "Unnamed"
    -- Position is set via a helper to ensure it's a valid, collision-free spawn point.
    self:setPosition(x or 100, y or 100)

    -- Common state for all characters
    self.isAlive = true
    self.speed = 100
    self.health = 100
    self.maxHealth = 100

    -- Common visual properties
    self.width = 32
    self.height = 32
    self.color = {1, 1, 1} -- Default white

    -- Common movement: velocity is now managed by the base update for physics.
    self.velocity = {x = 0, y = 0}
    -- NEW: Flag to enable/disable collision (useful for debugging or special abilities)
    self.collisionEnabled = true

    -- Track all created characters (useful for global updates/drawing)
    BaseCharacter.all = BaseCharacter.all or {}
    table.insert(BaseCharacter.all, self)
    print(string.format("Character '%s' created at (%d, %d)", self.name, self.x, self.y))
end

-- NEW: Safe position setter. Finds a valid spawn if the requested point is inside a wall.
function BaseCharacter:setPosition(x, y)
    if World and World.isPointInWall(x, y) then
        self.x, self.y = World.findSpawnLocation()
        print(string.format("%s spawned in wall, moved to (%d, %d)", self.name, self.x, self.y))
    else
        self.x = x
        self.y = y
    end
end

-- NEW: Returns a table representing the character's collision box.
-- Used by World.checkWallCollision and other character collision.
function BaseCharacter:getBoundingBox()
    return {x = self.x, y = self.y, width = self.width, height = self.height}
end

-- UPDATED: Main update loop. Applies velocity and resolves world collisions.
function BaseCharacter:update(dt)
    if not self.isAlive then return end

    -- Store the old position in case we need to revert due to collision
    local oldX, oldY = self.x, self.y

    -- Calculate new position based on velocity
    local newX = self.x + self.velocity.x * dt
    local newY = self.y + self.velocity.y * dt

    if self.collisionEnabled then
        -- SEPARATE-AXIS COLLISION RESOLUTION:
        -- 1. Try movement on the X-axis
        self.x = newX
        local collidesX = World.checkWallCollision(self:getBoundingBox())
        if collidesX then
            self.x = oldX -- Revert X movement if it caused a collision
            self.velocity.x = 0 -- Stop horizontal velocity
        end

        -- 2. Try movement on the Y-axis (from the potentially updated X position)
        self.y = newY
        local collidesY = World.checkWallCollision(self:getBoundingBox())
        if collidesY then
            self.y = oldY -- Revert Y movement
            self.velocity.y = 0 -- Stop vertical velocity
        end
    else
        -- If collision is disabled, move freely (for debugging or special states)
        self.x = newX
        self.y = newY
    end
end

-- Basic drawing method. Subclasses should override this for custom visuals.
function BaseCharacter:draw()
    love.graphics.setColor(self.color)
    love.graphics.rectangle('fill', self.x, self.y, self.width, self.height)
    love.graphics.setColor(1, 1, 1)
end

-- Set movement velocity. Called by Player input or Enemy AI.
function BaseCharacter:move(dx, dy)
    self.velocity.x = dx * self.speed
    self.velocity.y = dy * self.speed
end

-- Take damage. Override in subclasses for special death effects.
function BaseCharacter:takeDamage(amount)
    self.health = self.health - amount
    if self.health <= 0 then
        self:die()
    end
end

function BaseCharacter:die()
    self.isAlive = false
    print(string.format("%s has died!", self.name))
end

-- Check collision with another character using Axis-Aligned Bounding Box (AABB)
function BaseCharacter:collidesWith(other)
    local a = self:getBoundingBox()
    local b = other:getBoundingBox()
    return a.x < b.x + b.width and
           a.x + a.width > b.x and
           a.y < b.y + b.height and
           a.y + a.height > b.y
end

function BaseCharacter:getCenter()
    return self.x + self.width/2, self.y + self.height/2
end

-- Draws a simple health bar above the character if damaged.
function BaseCharacter:drawHealthBar()
    if self.health < self.maxHealth then
        local barWidth = 50
        local barHeight = 6
        local x = self.x + self.width/2 - barWidth/2
        local y = self.y - 15

        love.graphics.setColor(0.2, 0.2, 0.2) -- Background
        love.graphics.rectangle('fill', x, y, barWidth, barHeight)

        local healthPercent = self.health / self.maxHealth
        love.graphics.setColor(1 - healthPercent, healthPercent, 0) -- Green to Red
        love.graphics.rectangle('fill', x, y, barWidth * healthPercent, barHeight)

        love.graphics.setColor(1, 1, 1)
    end
end

-- === CLASS METHODS (Operate on all characters) ===
function BaseCharacter.getAllAlive()
    local alive = {}
    for _, char in ipairs(BaseCharacter.all or {}) do
        if char.isAlive then table.insert(alive, char) end
    end
    return alive
end

function BaseCharacter.updateAll(dt)
    for _, char in ipairs(BaseCharacter.all or {}) do
        if char.isAlive then char:update(dt) end
    end
end

function BaseCharacter.drawAll()
    for _, char in ipairs(BaseCharacter.all or {}) do
        if char.isAlive then
            char:draw()
            char:drawHealthBar()
        end
    end
end

return BaseCharacter



================================================
FILE: src/entities/Enemy.lua
================================================
-- src/entities/Enemy.lua
-- AI-controlled enemy character with network synchronization
local BaseCharacter = require "src.entities.BaseCharacter"

local Enemy = BaseCharacter:subclass('Enemy')

function Enemy:initialize(name, x, y, enemyType)
    -- Call parent constructor first
    BaseCharacter.initialize(self, name, x, y)

    -- Enemy-specific AI properties
    self.type = enemyType or "melee"
    self.damage = 10
    self.attackRange = 50
    self.aggroRange = 300  -- Increased for open arena
    self.attackCooldown = 1.5
    self.attackTimer = 0
    self.targetPlayer = nil
    self.enemyId = tostring(love.math.random(10000, 99999)) -- Unique ID for networking

    -- Type-specific property overrides
    if enemyType == "ranged" then
        self.color = {1, 0.5, 0}  -- Orange
        self.speed = 120
        self.aggroRange = 400
        self.attackRange = 200  -- Ranged enemies attack from farther
    elseif enemyType == "boss" then
        self.color = {0.5, 0, 0.5}  -- Purple
        self.width = 80
        self.height = 80
        self.health = 300
        self.maxHealth = 300
        self.speed = 80
        self.damage = 25
        self.attackRange = 80
    else -- "melee" (default)
        self.color = {0.8, 0.2, 0.2}  -- Red
        self.speed = 120
    end

    print(string.format("Enemy '%s' (%s) created at (%d, %d)",
          self.name, self.type, x, y))
end

-- Find closest player to target
function Enemy:findTarget(players)
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in ipairs(players) do
        if player.isAlive then
            local dx = player.x - self.x
            local dy = player.y - self.y
            local distance = math.sqrt(dx*dx + dy*dy)

            if distance < closestDistance and distance < self.aggroRange then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer, closestDistance
end

-- UPDATED: AI behavior with network synchronization
function Enemy:update(dt, players)
    -- 1. Update base movement and collision
    BaseCharacter.update(self, dt)

    -- 2. Update internal cooldown timer
    if self.attackTimer > 0 then
        self.attackTimer = self.attackTimer - dt
    end

    -- 3. Find and chase target
    if players and #players > 0 then
        local target, distance = self:findTarget(players)

        if target and target.isAlive then
            self.targetPlayer = target
            self:chase(target, dt, distance)
        else
            -- Idle behavior: wander randomly
            self:randomWander(dt)
        end
    else
        self:randomWander(dt)
    end
end

-- Random wandering when no target
function Enemy:randomWander(dt)
    -- Occasionally change direction
    if love.math.random() < 0.01 then
        self.wanderDirection = {
            x = love.math.random(-1, 1),
            y = love.math.random(-1, 1)
        }
    end

    if self.wanderDirection then
        self:move(self.wanderDirection.x, self.wanderDirection.y)
    end
end

-- Chase logic
function Enemy:chase(target, dt, distance)
    local dx = target.x - self.x
    local dy = target.y - self.y

    if distance > 0 then
        -- Normalize direction vector
        dx = dx / distance
        dy = dy / distance

        -- Use the parent's move method
        self:move(dx, dy)

        -- Check if we're in range to attack
        if distance < self.attackRange and self.attackTimer <= 0 then
            self:attack(target)
            self.attackTimer = self.attackCooldown
        end
    end
end

-- Attack function with network event
function Enemy:attack(target)
    if target.takeDamage then
        target:takeDamage(self.damage)
        print(self.name .. " attacks " .. target.name .. " for " .. self.damage .. " damage!")

        -- Create attack effect/visual
        self:createAttackEffect(target)
    end
end

-- Create visual attack effect
function Enemy:createAttackEffect(target)
    -- This can be expanded with particles or animations
    local effect = {
        type = "attack",
        attackerId = self.enemyId,
        targetId = target.name,
        damage = self.damage,
        x = target.x,
        y = target.y
    }

    -- In a networked game, this effect would be broadcast to all clients
    return effect
end

-- Draw enemy with special effects
function Enemy:draw()
    -- Draw shadow
    love.graphics.setColor(0, 0, 0, 0.3)
    love.graphics.rectangle('fill', self.x + 3, self.y + 5, self.width, self.height)

    -- Draw main body
    love.graphics.setColor(self.color)
    love.graphics.rectangle('fill', self.x, self.y, self.width, self.height)

    -- Draw enemy eyes
    love.graphics.setColor(1, 1, 1)
    local eyeSize = math.max(4, self.width / 8)
    love.graphics.rectangle('fill', self.x + self.width/4, self.y + self.height/3, eyeSize, eyeSize)
    love.graphics.rectangle('fill', self.x + self.width*3/4 - eyeSize, self.y + self.height/3, eyeSize, eyeSize)

    -- Draw attack cooldown indicator
    if self.attackTimer > 0 then
        local cooldownPercent = self.attackTimer / self.attackCooldown
        love.graphics.setColor(1, 1 - cooldownPercent, 0, 0.5)
        love.graphics.rectangle('fill', self.x, self.y - 10, self.width * cooldownPercent, 3)
    end

    love.graphics.setColor(1, 1, 1)
end

-- NETWORKING: Creates state snapshot for the enemy
function Enemy:getNetworkState()
    return {
        id = self.enemyId,
        x = math.floor(self.x + self.width/2),   -- Center X
        y = math.floor(self.y + self.height/2),  -- Center Y
        health = self.health,
        type = self.type,
        alive = self.isAlive and 1 or 0
    }
end

-- NETWORKING: Applies network state to the enemy
function Enemy:applyNetworkState(state)
    if state.x and state.y then
        -- Convert center to top-left
        self.x = state.x - self.width/2
        self.y = state.y - self.height/2
    end
    self.health = state.health or self.health
    self.isAlive = (state.alive == 1) or state.alive == true
end

-- Take damage with death notification
function Enemy:takeDamage(amount)
    BaseCharacter.takeDamage(self, amount)

    if not self.isAlive then
        -- Enemy died - could trigger death effect/score here
        print(self.name .. " has been defeated!")
    end
end

return Enemy



================================================
FILE: src/entities/Player.lua
================================================
-- src/entities/Player.lua
-- Represents the player-controlled character with actions
local BaseCharacter = require "src.entities.BaseCharacter"

local Player = BaseCharacter:subclass('Player')

function Player:initialize(name, x, y)
    -- FIRST, call the parent class's constructor
    BaseCharacter.initialize(self, name, x, y)

    -- Player-specific properties
    self.score = 0
    self.inventory = {}
    self.isLocalPlayer = false -- CRITICAL: Determines if this instance accepts input.

    -- Action system
    self.actions = {
        attack = {cooldown = 0.5, timer = 0, damage = 20, range = 60},
        special = {cooldown = 2.0, timer = 0, damage = 40, range = 100},
        dash = {cooldown = 1.0, timer = 0, distance = 100}
    }

    -- Visual properties
    self.speed = 150
    self.color = {0.2, 0.6, 1} -- Player Blue
    self.width = 40
    self.height = 60

    -- Action state
    self.currentAction = nil
    self.actionTarget = nil
    self.actionStartTime = 0
    self.actionDuration = 0.2
end

-- UPDATED: Update with action cooldowns
function Player:update(dt)
    -- Update action cooldowns
    for actionName, action in pairs(self.actions) do
        if action.timer > 0 then
            action.timer = action.timer - dt
        end
    end

    -- Update current action
    if self.currentAction then
        local elapsed = love.timer.getTime() - self.actionStartTime
        if elapsed >= self.actionDuration then
            self:completeAction()
        end
    end

    if self.isLocalPlayer then
        self:handleInput(dt) -- Process keyboard input
        self:handleActions() -- Process action input
    end

    -- Call the parent update to apply velocity and resolve collisions
    BaseCharacter.update(self, dt)
end

-- Handle keyboard input for movement
function Player:handleInput(dt)
    local dx, dy = 0, 0

    if love.keyboard.isDown('w', 'up') then dy = -1 end
    if love.keyboard.isDown('s', 'down') then dy = 1 end
    if love.keyboard.isDown('a', 'left') then dx = -1 end
    if love.keyboard.isDown('d', 'right') then dx = 1 end

    -- Normalize diagonal movement
    if dx ~= 0 and dy ~= 0 then
        dx = dx * 0.7071 -- 1 / sqrt(2)
        dy = dy * 0.7071
    end

    -- Set the velocity
    self:move(dx, dy)

    -- Stop if no keys are pressed
    if dx == 0 and dy == 0 then
        self.velocity.x = 0
        self.velocity.y = 0
    end
end

-- Handle action input
function Player:handleActions()
    -- Attack action (Space)
    if love.keyboard.isDown('space') and self:canPerformAction('attack') then
        self:performAction('attack')
    end

    -- Special action (Shift)
    if love.keyboard.isDown('lshift', 'rshift') and self:canPerformAction('special') then
        self:performAction('special')
    end

    -- Dash action (F key)
    if love.keyboard.isDown('f') and self:canPerformAction('dash') then
        self:performAction('dash')
    end
end

-- Check if action can be performed
function Player:canPerformAction(actionName)
    local action = self.actions[actionName]
    return action and action.timer <= 0 and not self.currentAction
end

-- Perform an action
function Player:performAction(actionName)
    local action = self.actions[actionName]
    if not action then return end

    -- Start the action
    self.currentAction = actionName
    self.actionStartTime = love.timer.getTime()
    action.timer = action.cooldown

    -- Find target for attack actions
    if actionName == 'attack' or actionName == 'special' then
        self:findActionTarget()
    end

    -- Handle dash action
    if actionName == 'dash' then
        self:performDash()
    end

    -- Create action effect
    local actionData = self:createActionEffect()

    -- Network: Send action to server if we're a client
    if self.isLocalPlayer and not Network.isServer then
        Network.sendPlayerAction(actionData)
    end

    print(self.name .. " performs " .. actionName .. " action!")
end

-- Complete current action
function Player:completeAction()
    if not self.currentAction then return end

    -- Apply damage if attack action
    if self.currentAction == 'attack' or self.currentAction == 'special' then
        if self.actionTarget then
            self:applyActionDamage()
        end
    end

    -- Clear action state
    self.currentAction = nil
    self.actionTarget = nil
end

-- Find target for attack actions
function Player:findActionTarget()
    -- Get all potential targets (enemies, other players)
    local allTargets = {}

    -- Add enemies
    for _, enemy in ipairs(BaseCharacter.getAllAlive() or {}) do
        if enemy.class and enemy.class.name == 'Enemy' then
            table.insert(allTargets, enemy)
        end
    end

    -- Find closest target in range
    local action = self.actions[self.currentAction]
    local closestTarget = nil
    local closestDistance = math.huge

    for _, target in ipairs(allTargets) do
        local distance = self:distanceTo(target)
        if distance <= action.range and distance < closestDistance then
            closestDistance = distance
            closestTarget = target
        end
    end

    self.actionTarget = closestTarget
end

-- Apply damage to action target
function Player:applyActionDamage()
    if not self.actionTarget then return end

    local action = self.actions[self.currentAction]
    self.actionTarget:takeDamage(action.damage)

    print(string.format("%s hits %s for %d damage!",
          self.name, self.actionTarget.name, action.damage))
end

-- Perform dash movement
function Player:performDash()
    local action = self.actions.dash

    -- Dash in current movement direction or last direction
    local dashX, dashY = 0, 0
    if math.abs(self.velocity.x) > 0 or math.abs(self.velocity.y) > 0 then
        -- Normalize velocity for dash direction
        local length = math.sqrt(self.velocity.x^2 + self.velocity.y^2)
        dashX = (self.velocity.x / length) * action.distance
        dashY = (self.velocity.y / length) * action.distance
    else
        -- Default dash forward (based on last direction or facing)
        dashY = -action.distance  -- Dash upward by default
    end

    -- Apply dash (temporarily disable collision for dash)
    local oldCollision = self.collisionEnabled
    self.collisionEnabled = false
    self.x = self.x + dashX
    self.y = self.y + dashY
    self.collisionEnabled = oldCollision
end

-- Create action effect data for networking
function Player:createActionEffect()
    local action = self.actions[self.currentAction]

    local effect = {
        playerId = self.name,
        action = self.currentAction,
        x = self.x + self.width/2,
        y = self.y + self.height/2,
        direction = {x = self.velocity.x, y = self.velocity.y},
        timestamp = love.timer.getTime()
    }

    -- Add target info if available
    if self.actionTarget then
        effect.targetId = self.actionTarget.name
        effect.targetX = self.actionTarget.x
        effect.targetY = self.actionTarget.y
    end

    return effect
end

-- Override draw to show action effects
function Player:draw()
    -- Draw a shadow for depth
    love.graphics.setColor(0, 0, 0, 0.3)
    love.graphics.rectangle('fill', self.x + 3, self.y + 5, self.width, self.height)

    -- Draw the main body
    love.graphics.setColor(self.color)
    love.graphics.rectangle('fill', self.x, self.y, self.width, self.height)

    -- Draw action indicator
    if self.currentAction then
        local progress = (love.timer.getTime() - self.actionStartTime) / self.actionDuration
        love.graphics.setColor(1, 1, 0, 0.5 * (1 - progress))
        love.graphics.rectangle('line', self.x - 5, self.y - 5,
                               self.width + 10, self.height + 10)
    end

    -- Draw cooldown indicators
    local indicatorY = self.y - 20
    for actionName, action in pairs(self.actions) do
        if action.timer > 0 then
            local cooldownPercent = action.timer / action.cooldown
            local color = {1, 1 - cooldownPercent, 0}

            love.graphics.setColor(color[1], color[2], color[3], 0.7)
            love.graphics.rectangle('fill', self.x, indicatorY,
                                   self.width * cooldownPercent, 3)
            indicatorY = indicatorY - 5
        end
    end

    -- Draw eyes - color indicates if this is the local player
    if self.isLocalPlayer then
        love.graphics.setColor(1, 1, 0) -- Yellow for local
    else
        love.graphics.setColor(1, 0, 0) -- Red for remote/networked players
    end
    love.graphics.rectangle('fill', self.x + 10, self.y + 15, 6, 6)
    love.graphics.rectangle('fill', self.x + 24, self.y + 15, 6, 6)

    love.graphics.setColor(1, 1, 1)
end

-- NETWORKING: Creates a compact state snapshot to send over the network
function Player:getNetworkState()
    return {
        x = math.floor(self.x + self.width/2),   -- Send CENTER X
        y = math.floor(self.y + self.height/2),  -- Send CENTER Y
        health = self.health,
        alive = self.isAlive and 1 or 0,
        actions = {  -- Include action states
            attack = self.actions.attack.timer,
            special = self.actions.special.timer,
            dash = self.actions.dash.timer
        }
    }
end

-- NETWORKING: Applies a state snapshot received from the network
function Player:applyNetworkState(state)
    -- Convert from center to top-left corner
    self.x = state.x - self.width/2
    self.y = state.y - self.height/2
    self.health = state.health
    self.isAlive = (state.alive == 1)

    -- Update action cooldowns if provided
    if state.actions then
        for actionName, timer in pairs(state.actions) do
            if self.actions[actionName] then
                self.actions[actionName].timer = timer or 0
            end
        end
    end
end

-- Apply action effect from network
function Player:applyActionEffect(effectData)
    -- Visual effect for remote player actions
    if effectData.action == 'attack' or effectData.action == 'special' then
        self:showActionEffect(effectData)
    elseif effectData.action == 'dash' then
        self:showDashEffect(effectData)
    end
end

-- Show visual effect for action
function Player:showActionEffect(effectData)
    -- This would trigger particles/animations
    -- For now, just log it
    print(string.format("%s performs %s at (%d, %d)",
          effectData.playerId, effectData.action, effectData.x, effectData.y))
end

-- Show dash effect
function Player:showDashEffect(effectData)
    -- Visual trail effect for dash
    print(string.format("%s dashes!", effectData.playerId))
end

return Player



================================================
FILE: src/ui/BaseMenu.lua
================================================
-- src/ui/BaseMenu.lua
-- Generic, reusable menu base class using middleclass.
local class = require "lib.middleclass"

local BaseMenu = class('BaseMenu')

-- Constructor: Initialize the menu with a title and list of options.
-- @param title (string) The menu title.
-- @param options (table) Array of option tables: {text="Option Text", callback=function}
function BaseMenu:initialize(title, options)
    self.title = title or "Menu"
    self.options = options or {}
    self.selectedIndex = 1 -- Start with the first option selected.
    self.isActive = false  -- Menu is not visible/active by default.
    print(string.format("Menu '%s' created with %d options", self.title, #self.options))
end

-- Activates the menu, making it visible and interactive.
function BaseMenu:activate()
    self.isActive = true
    self.selectedIndex = 1 -- Reset selection when activated.
    print("Menu activated:", self.title)
end

-- Deactivates the menu.
function BaseMenu:deactivate()
    self.isActive = false
    print("Menu deactivated:", self.title)
end

-- Moves the selection up.
function BaseMenu:selectPrevious()
    if not self.isActive then return end
    self.selectedIndex = self.selectedIndex - 1
    if self.selectedIndex < 1 then
        self.selectedIndex = #self.options -- Wrap to bottom.
    end
end

-- Moves the selection down.
function BaseMenu:selectNext()
    if not self.isActive then return end
    self.selectedIndex = self.selectedIndex + 1
    if self.selectedIndex > #self.options then
        self.selectedIndex = 1 -- Wrap to top.
    end
end

-- Triggers the callback of the currently selected option.
function BaseMenu:selectCurrent()
    if not self.isActive then return end
    local option = self.options[self.selectedIndex]
    if option and option.callback then
        print("Menu selected:", option.text)
        option.callback() -- Execute the option's action.
    end
end

-- Draws the menu. Should be called in love.draw().
-- This is a generic implementation; subclasses should override for custom visuals.
-- @param x (number) X position to draw the menu.
-- @param y (number) Y position to draw the menu.
function BaseMenu:draw(x, y)
    if not self.isActive then return end
    x = x or 100
    y = y or 100
    love.graphics.setColor(1, 1, 1) -- White.
    -- Draw the title.
    love.graphics.print(self.title, x, y)
    -- Draw each option, highlighting the selected one.
    for i, option in ipairs(self.options) do
        local optionY = y + 40 + (i * 30) -- Positioning.
        if i == self.selectedIndex then
            love.graphics.setColor(0, 1, 0) -- Green for selected.
            love.graphics.print("> " .. option.text, x, optionY)
        else
            love.graphics.setColor(0.7, 0.7, 0.7) -- Grey for unselected.
            love.graphics.print("  " .. option.text, x, optionY)
        end
    end
    love.graphics.setColor(1, 1, 1)
end

-- Updates the menu. Should be called in love.update(dt).
-- Add any animations or timed logic here if needed.
function BaseMenu:update(dt)
    if not self.isActive then return end
    -- Placeholder for any per-frame updates (e.g., animations).
end

return BaseMenu



================================================
FILE: src/ui/MainMenu.lua
================================================
-- src/ui/MainMenu.lua
-- Main menu screen with host/join functionality
-- Inherits from BaseMenu for common menu functionality

local BaseMenu = require "src.ui.BaseMenu"

local MainMenu = BaseMenu:subclass('MainMenu')

-- Constructor: Sets up menu options and callbacks
function MainMenu:initialize()
    local menuOptions = {
        {
            text = "Host Game",
            callback = function()
                print("Main Menu: Host Game selected")
                self:onHostSelected()
            end
        },
        {
            text = "Join Game",
            callback = function()
                print("Main Menu: Join Game selected")
                self:onJoinSelected()
            end
        },
        {
            text = "Exit",
            callback = function()
                print("Main Menu: Exit selected")
                self:onExitSelected()
            end
        }
    }

    -- Initialize base menu with our options
    BaseMenu.initialize(self, "Main Menu", menuOptions)

    -- Network module reference (set by main.lua)
    self.network = nil
end

-- Called when "Host Game" is selected
function MainMenu:onHostSelected()
    if self.network then
        self:deactivate()
        -- IMPORTANT: Directly call Network.init, not self.network.init
        -- The network module is already loaded by main.lua
        local Network = require "src.core.Network"
        Network.init("localhost", 22122, true)
        print("Main Menu: Starting as SERVER (Host)...")
        -- Local player will be created via Network.setHostCreatedCallback
    else
        print("ERROR: Network module not connected to menu")
    end
end

-- Called when "Join Game" is selected
function MainMenu:onJoinSelected()
    if self.network then
        self:deactivate()
        -- IMPORTANT: Directly call Network.init
        local Network = require "src.core.Network"
        Network.init("localhost", 22122, false)
        print("Main Menu: Starting as CLIENT...")
        -- Client will wait for server connection
    else
        print("ERROR: Network module not connected to menu")
    end
end

-- Called when "Exit" is selected
function MainMenu:onExitSelected()
    love.event.quit()
end

-- Custom draw method with improved visuals
function MainMenu:draw()
    if not self.isActive then return end

    -- Semi-transparent background overlay
    love.graphics.setColor(0, 0, 0, 0.8)
    love.graphics.rectangle("fill", 100, 50, 600, 500)

    -- Menu title with centered alignment
    love.graphics.setColor(1, 1, 1)
    love.graphics.setFont(love.graphics.newFont(24))
    local titleWidth = love.graphics.getFont():getWidth(self.title)
    love.graphics.print(self.title, (800 - titleWidth) / 2, 80)

    -- Draw menu options with selection indicator
    for i, option in ipairs(self.options) do
        local y = 150 + (i * 40)

        -- Highlight selected option
        if i == self.selectedIndex then
            love.graphics.setColor(0, 1, 0)  -- Green for selected
            love.graphics.print("> " .. option.text, 200, y)
        else
            love.graphics.setColor(0.7, 0.7, 0.7)  -- Gray for unselected
            love.graphics.print("  " .. option.text, 200, y)
        end
    end

    -- Instructions footer
    love.graphics.setColor(1, 1, 1)
    love.graphics.setFont(love.graphics.newFont(14))
    love.graphics.print("Use UP/DOWN arrows to navigate, ENTER to select", 200, 450)
    love.graphics.print("Press ESC to return/quit", 200, 470)
end

return MainMenu


